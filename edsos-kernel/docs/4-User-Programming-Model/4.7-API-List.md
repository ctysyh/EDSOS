<!--
SPDX-FileCopyrightText: © 2025-2026 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

## **1.2.3 节点操作与生命周期**

### **1.2.3.1 原子操作语义**

#### **1.2.3.1.1 `push`：原子创建，无中间态**

- **语义**：创建新叶子节点，挂载为当前节点的子节点。
- **触发者**：当前 running 节点（如函数调用、线程 spawn）。
- **起始和目标状态**：空内容 → ready。
- **原子性保证**：
  - 内存子系统必须 **一次性分配所有 VPs**；
  - 若 VP 不足 → 返回错误，不创建部分节点；
  - 跨机 push：目标 PM 完成 VP 分配 + 祖先链验证后，才返回成功。
- **并行性**：多个核心可并发 push 不同父节点的子节点，无冲突。
- **无需中间态**。

#### **1.2.3.1.2 `active`：调度器驱动的上下文激活**

- **语义**：将 ready 节点调度到 CPU 核心执行。
- **触发者**：调度器。
- **起始和目标状态**：ready → running。
- **关键点**：
  - **不限于叶子节点**：父子可并行（如协程 + 主线程）；
  - **调度器责任**：
    1. 选择 ready 节点；
    2. 重建其祖先链（通过父指针遍历）；
    3. **增量 TLB 预热**（L1: 自身；L2: 祖先）；
    4. 加载寄存器上下文；
    5. 切换到 running。
- **失败处理**：
  - TLB 预热失败（罕见）→ 标记 error，尝试下一节点；
  - 无 ready 节点 → 进入 idle。
- **并行模型**：同片/跨片核心调度逻辑一致，仅 TLB 预热延迟不同。

#### **1.2.3.1.3 `wait`：阻塞与信号驱动唤醒**

- **语义**：节点主动放弃 CPU，等待某信号（I/O 完成、锁释放等）。
- **起始和目标状态**：running → blocked。
- **实现机制**：
  - 节点调用 `edsos_wait(semaphore_id)`；
  - EDSOS 将节点加入 **semaphore_id 的等待队列**；
  - 状态转为 blocked；
  - 当信号发生，**信号管理器**遍历队列，将节点状态转为 ready。
- **关键要求**：
  - **唤醒必须精准**：避免虚假唤醒（spurious wakeup）；
  - **无竞态**：wait 与 semaphore_signal 需原子协调（通过内存子系统信号总线）。
- **并行性**：多个节点可 wait 同一信号，无冲突。

#### **1.2.3.1.4 `pivot`：结构变更，需 yield**

- **语义**：将节点挂载到更高祖先下，改变其作用域。
- **起始和目标状态**：结构变更。
- **无需中间状态**，但需 **yield 所有子孙节点**。
- **详细流程**：
  1. 节点发起 pivot(target_ancestor_gva)；
  2. EDSOS 验证 target_ancestor 在 AS 树中（通过 LVA 遍历）；
  3. **暂停所有子孙节点**（递推调用 `yield`）；
  4. 原子更新父指针；
  5. 子孙节点状态仍为 ready，但下次 active 时将使用新祖链。
- **为什么无需 pivot_pending**？
  - 因为 **作用域变更对子孙不可见，直到它们被重新调度**；
  - TLB 是 per-core 的，旧核心的 TLB 仍有效，直到被刷新；
  - **安全由调度器保证**：子孙下次运行时，TLB 预热基于新父链。
- **跨机 pivot**：跨机传输新挂载点，目标 PM 执行相同 yield + 更新；通过代理根节点（缓存本机子树的根节点之上的信息，接收其他 PM 发来的作用到本机子树根节点的直系祖节点链的结构变更消息）和代理子节点（缓存本机父树的从一个节点开始的子树在其他 PM 的信息，接收其他 PM 发来的从子树向上作用到这个节点的结构变更消息）来在每个 PM 中缓存信息，减少频繁跨机访问开销。

#### **1.2.3.1.5 `merge`：扩容操作，需 yield**

- **语义**：将自身与一个“扩展子节点”合并，扩大虚拟地址范围。
- **起始和目标状态**：结构变更。
- **流程**：
  1. 先 `push` 一个扩展子节点（仅数据段）；
  2. 调用 `merge(child_gva)`；
  3. **yield 自身**（若 running）；
  4. 内存子系统 **虚拟重映射**：将 child 的 VPs 合并到父的地址空间；
  5. 更新 `vbase/size`；
  6. 子节点标记为 zombie；
  7. 自身状态仍为 ready（若原为 ready）或 running（下次调度恢复）。
- **关键**：merge 期间，**自身不能执行**，故需 yield。
- **无需 merge_pending**：因操作在 yield 保护下原子完成。

---

#### **1.2.3.1.6 `detach`：分裂操作，需 yield**

- **语义**：将部分数据分裂为新子节点，用于回收或 pivot。
- **起始和目标状态**：结构变更。
- **流程**：
  1. **yield 自身**；
  2. 内存子系统分配新 VPs；
  3. 迁移数据；
  4. 创建新子节点（状态 ready）；
  5. 更新自身 `vbase/size`；
  6. 恢复状态。
- **典型场景**：冷数据回收 → detach → pivot 到全局缓存池。

---

#### **1.2.3.1.7 `yield`：中断驱动的上下文冻结**

- **语义**：将 running 节点暂停，保存上下文，回到 ready。
- **起始和目标状态**：running → ready。
- **触发场景**：
  - 定时器中断（时间片到期）；
  - TLB 一致性中断（跨核 TLB 刷新）；
  - 调度器主动抢占；
  - pivot/merge/detach 需要暂停。
- **操作**：
  - 保存寄存器；
  - 状态 → ready；
  - **不清空 TLB**（下次 active 可复用，除非祖链变更）。

---

#### **1.2.3.1.8 `finish`：正常退出**

- **语义**：节点执行完毕，进入 zombie。
- **触发**：`return` 或 `edsos_exit()`。
- **起始和目标状态**：running → zombie。
- **行为**：
  - 若有子节点，**递归 finish**（AS 子树语义）；
  - 父节点可 later `pop`。

---

#### **1.2.3.1.9 `pop`：父节点回收子节点**

- **语义**：父节点显式回收已 zombie 的子节点。
- **起始和目标状态**：zombie → 空内容。
- **原子性**：检查子节点状态 == zombie → 释放内存 → 删除父指针。
- **跨机 pop**：通过代理子节点向对应的远程 PM 中的代理根节点发送 `pop` 消息。

---

#### **1.2.3.1.10 `warn`：安全异常**

- **语义**：强制进入 error 状态，终止子树。
- **起始和目标状态**：any → error。
- **触发**：
  - Page Fault 验证失败（访问非法地址）；
  - 元数据 magic 错误；
  - 签名无效；
  - 其他异常和错误。
- **行为**：
  - 状态 → error；
  - **递归 error 所有子孙**；
  - 上报安全日志；
  - 父节点可选择 ignore 或 terminate。