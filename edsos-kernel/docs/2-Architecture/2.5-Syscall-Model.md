<!--
SPDX-FileCopyrightText: © 2025-2026 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 2.5 系统调用模型

---

> v0.1.3-drafting

---

- [2.5 系统调用模型](#25-系统调用模型)
  - [2.5.1 第一类系统调用架构](#251-第一类系统调用架构)
    - [2.5.1.1 定义与核心特征](#2511-定义与核心特征)
    - [2.5.1.2 接口分类与具体实现](#2512-接口分类与具体实现)
      - [2.5.1.2.1 调度器 NOI 中可被用户代码直接调用的接口](#25121-调度器-noi-中可被用户代码直接调用的接口)
      - [2.5.1.2.2 本地元数据查询接口（非 NOI，但属第一类）](#25122-本地元数据查询接口非-noi但属第一类)
  - [2.5.2 第二类系统调用架构](#252-第二类系统调用架构)
    - [2.5.2.1 适用范围界定](#2521-适用范围界定)
    - [2.5.2.2 SPN 作为高效通信通道](#2522-spn-作为高效通信通道)
    - [2.5.2.3 执行流程](#2523-执行流程)
    - [2.5.2.4 安全与性能特性](#2524-安全与性能特性)
  - [2.5.3 兼容模式支持（POSIX / Win32 / Native）](#253-兼容模式支持posix--win32--native)


---

## 2.5.1 第一类系统调用架构

### 2.5.1.1 定义与核心特征

第一类 syscall 是 **由调度器在本地 CPU 核心上直接、同步地完成处理**，且操作的影响范围限定在 **当前 AS 节点自身、其子树内部，或仅涉及只读的元数据查询** 的系统调用。

第一类 syscall 由应用程序代码按照桩函数形式调用，由 EDSOS Loader 在加载期静态内联展开为机器指令，直接操作调度器本地数据结构（如 Ready Forest, Wait Graph）或读取本地元数据。

### 2.5.1.2 接口分类与具体实现

第一类 syscall 可分为两大类：**属于调度器 NOI（Normal Open Interface）的** 和 **本地元数据查询接口**。

#### 2.5.1.2.1 调度器 NOI 中可被用户代码直接调用的接口

这些接口是用户代码 **主动控制自身执行流和结构** 的主要手段，包括以下内容：

- **节点操作 (Node Operations)**：
  - 即符合 AS 模型定义节点状态机操作。
- **信号操作 (Semaphore Operations)**：
  - 即 §2.3.3.1 中定义的信号操作。
- **调度请求 (Scheduling Hints & Control)**：
  - **同步**：Mutex / RWLock / Semaphore / Condition Variable 等。
  - **主动让出/延长**：`edsos_yield()` (触发立即调度) / `edsos_extend_quota(...)` (请求延长当前时间片，调度器根据策略决定是否批准)。
  - **CPU 亲和性与隔离**：`edsos_set_affinity(core_mask)` / `edsos_request_isolation()`。这些调用**不直接绑定**，而是向调度器的负载均衡模块（Work-Stealing++）提供**策略权重提示**，可能影响子树迁移决策。
  - **优先级提示**：`edsos_set_priority_hint(level)`。影响节点在 Ready Linked List 中的**智能顺位插入**位置（见 §2.3.2.3.1）。
- **时钟请求 (Clock Access)**：
  - **低精度时钟**：`edsos_get_coarse_time()`。返回一个模糊化、低分辨率的时钟值，用于非精确计时。
  - **不信任高精度时钟**：`edsos_get_untrusted_time()`。返回基于调度器记录的节点执行时间，并经过**模糊化和偏移处理**的值，旨在**防御时序侧信道攻击**。
  - **信任高精度时钟**：`edsos_get_trusted_time()`。**仅当进程的 Capability 政策允许**时，Loader 才会将此桩函数内联为直接读取硬件 ASC 的指令，否则会默认内联成为不信任高精度时钟。
- **性能查询 (Performance Profiling)**：
  - `edsos_get_execution_time()`: 返回调度器为当前节点记录的**累计 CPU 执行时间**。
  - `edsos_get_cache/TLB_miss_stats()`: 返回由硬件性能计数器（PMC）采样并由调度器聚合的**缓存/TLB Miss 估计值**。这些数据由调度器在上下文切换时采样获得。

#### 2.5.1.2.2 本地元数据查询接口（非 NOI，但属第一类）

这些接口不改变调度器状态，仅用于 **查询** 根节点或 SPN 中的 **应用只读信息**，包括以下内容：

- **硬件信息查询 (Hardware Info)**：
  - 查询记录在 SPN 中的硬件注册信息。此数据由 Capability 政策决定，并可在运行时随符合政策的硬件连接/断开而即时更新。此信息 **可能被根权限篡改**，但系统会同时提供一个 `is_info_tampered` 标志位告知应用程序。
- **进程与线程信息查询 (Process/Thread Info)**：
  - `edsos_get_ts_id()`: 返回当前 AS 的全局唯一标识符（PID），该值存储在根节点中。
  - 在兼容模式下，为模拟传统线程模型，`edsos_get_thread_id()` 会返回其所属 AS 的 ID，因为 EDSOS 中不存在独立的“线程”概念。
- **权限查询 (Permission/Capability Query)**：
  - 查询存储在 SPN 中的 **系统服务访问入口**。例如：`edsos_can_access_network()`。

> 完整的接口列表详见 [4.7 API List](../4-User-Programming-Model/4.7-API-List.md) 和 [4.8 ABI List](../4-User-Programming-Model/4.8-ABI-List.md) 两篇文档。

---

## 2.5.2 第二类系统调用架构

第二类系统调用用于处理复杂、敏感、耗时或跨作用域的操作。与第一类系统调用的本地同步执行模式不同，第二类系统调用采用**异步委托**机制：调用请求由调度器转发至专用的系统服务组件 AS（如文件服务、网络协议栈），并通过结构化的共享通道完成参数传递与结果返回。该机制是 EDSOS 实现完整操作系统功能的核心路径。

### 2.5.2.1 适用范围界定

第二类系统调用的判定依据为操作的执行语义与安全影响。典型场景包括：

- 所有 I/O 操作（如文件读写、网络通信、设备控制）；
- 资源创建与管理（如创建 CARN 或全局信号对象）；
- 高权限或全局状态变更（如修改系统时间、加载动态模块）；
- 需复杂协议或状态机处理的操作（如数据库事务）。

在 POSIX/Win32 兼容模式下，若启用了弱安全选项，部分本可归为第一类的调用（如 `getpid()`、`clock_gettime()`）会被强制降级为第二类，以确保行为与传统操作系统一致。

综上，任何需由系统服务代表调用者执行并返回结果的操作，均属于第二类系统调用。

此外，该执行流程亦可用于应用 AS 之间的协作：一个 AS 可通过注册表服务组件公开其接口及访问控制回调，使其他 AS 在主动查询并注入后能够调用，但不会在注册时自动注入至其他 AS 的 SPN。

### 2.5.2.2 SPN 作为高效通信通道

SPN（System Proxy Node）是一种特殊的 CARN，用于在调用者 AS 与系统服务组件之间建立安全、高效的异步通信通道。

1. **SPN 的定义与功能**  
   SPN 具备以下核心特性：
   - **参数与返回值缓冲区**：提供调用者与服务组件共享的结构化内存区域，用于传递调用参数和接收返回结果；
   - **信号协调器**：关联一对同步信号（请求信号与响应信号），实现阻塞-唤醒语义；
   - **桩函数载体**：在 AS 加载阶段，EDSOS Loader 根据 Manifest 中声明的 Capability 策略，将第二类系统调用的桩函数逻辑内联展开并注入 SPN 的指令段。应用代码对系统调用的调用最终转化为对 SPN 指令段的直接跳转。

2. **SPN 的挂载拓扑**  
   SPN 的挂载遵循局部性原则：
   - 每个 AS 在每个 CPU 核心上的本地子树根（Local Subtree Root, LSR）——无论是 AS 根节点还是调度器创建的代理根节点——均挂载一个 SPN 作为其直接子节点；
   - 该 SPN 的作用域仅对本地子树内的节点可见。因此，分配至不同核心的同一 AS 节点访问的是不同的 SPN 实例，从根本上避免跨核并发冲突。

3. **SPN 的使用方式**  
   SPN 对应用开发者完全透明：
   - 编译期：应用代码调用标准系统调用接口；
   - 加载期：EDSOS Loader 根据 Capability 策略，将对应桩函数内联展开为对 SPN 指令段的跳转，并注入参数布局逻辑；
   - 运行期：调用者节点执行内联代码，写入参数、触发请求信号、等待响应信号，整个过程表现为一次“看似同步”的函数调用，实则为信号驱动的异步交互。

4. **安全子节点与大数据访问机制**  
   对于涉及大块数据（如文件内容、网络包、GPU 纹理）的操作，SPN 通过**安全子节点**（Secure Child Node）机制扩展：
   - 安全子节点是由系统服务组件 AS 创建并挂载于 SPN 下的特殊 CARN，可包含指令段以实现数据处理逻辑；
   - 安全子节点不在调用者节点的直系祖先链上，因此不可被直接访问，具备隔离性；
   - 为高效访问其数据，EDSOS 提供两种受控机制：
     - **只读映射窗口**：调度器在构建调用者页表时，将安全子节点的数据页以只读权限预热至 TLB，调用者可直接读取；
     - **SDSC 安全访问指令**：服务组件可将对安全子节点的读写操作封装为 SDSC（Scheduler-Driven Semaphore Closure）。当调用者触发访问请求信号时，调度器直接执行该 SDSC 完成数据拷贝或更新。此方式支持安全读写，但并发控制由服务组件自行处理。

### 2.5.2.3 执行流程

第二类系统调用的完整生命周期遵循异步生产者-消费者模型，由调度器与 EDSOS Semaphore 协同驱动：

1. **用户端发起调用**  
   用户代码调用第二类系统调用桩函数（例如 `edsos_file_read(fd, buf, size)`）。EDSOS Loader 已将其展开为写入 SPN 参数缓冲区的指令序列。调用末尾自动执行 `edsos_wait(kpn_response_semaphore)`，将当前节点置为 `blocked` 状态。

2. **服务端触发**  
   参数写入完成后，桩函数通过调度器 NOI（如 `edsos_signal(service_request_semaphore)`）或链式消息总线通知对应系统服务组件 AS。

3. **服务端处理与响应**  
   服务组件 AS 被调度执行后，读取 SPN 中的请求参数并执行操作：
   - 若返回数据量小（如错误码、元数据），直接写入 SPN 的返回值槽位；
   - 若返回数据量大，服务组件创建一个新的 CARN 子节点（含数据段与可选指令段），将其挂载为 SPN 的子节点，并将关键元数据（如长度、句柄）写入 SPN 返回槽位。

4. **用户端唤醒与数据消费**  
   服务组件完成处理后，调用 `edsos_signal(kpn_response_semaphore)` 唤醒阻塞的用户节点。用户节点恢复执行，从 SPN 读取结果或通过安全子节点访问大块数据。

### 2.5.2.4 安全与性能特性

- **安全性**：SPN 的结构化设计实现了最小权限原则。调用者无法访问服务组件的内部状态，服务组件亦无法越权修改调用者内存。
- **性能**：通过零拷贝数据传递、异步非阻塞执行模型及局部性优化，第二类系统调用的开销显著低于传统陷入-返回式系统调用。
- **可组合性**：SPN 作为标准化接口，支持系统服务以微服务形式独立开发、部署与更新，提升系统模块化程度与可维护性。

---

## 2.5.3 兼容模式支持（POSIX / Win32 / Native）

<TODO>