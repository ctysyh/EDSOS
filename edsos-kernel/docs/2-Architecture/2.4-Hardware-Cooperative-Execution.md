<!--
SPDX-FileCopyrightText: © 2025-2026 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 2.4 硬件协同执行模型

---

> v0.1.3-drafting

---

- [2.4 硬件协同执行模型](#24-硬件协同执行模型)
  - [2.4.1 TLB 驱动的作用域访问控制](#241-tlb-驱动的作用域访问控制)
    - [2.4.1.1 页表项的二元状态设计](#2411-页表项的二元状态设计)
    - [2.4.1.2 TLB 层次结构与作用域语义对齐](#2412-tlb-层次结构与作用域语义对齐)
    - [2.4.1.3 异常处理：Page Fault 作为越界信号](#2413-异常处理page-fault-作为越界信号)
    - [2.4.1.4 边界情况与优雅退化](#2414-边界情况与优雅退化)
  - [2.4.2 PCID 作为祖链指纹](#242-pcid-作为祖链指纹)
  - [2.4.3 调度预热机制](#243-调度预热机制)
    - [2.4.3.1 预热范围的增量计算：基于最小公共祖先（LCA）](#2431-预热范围的增量计算基于最小公共祖先lca)
    - [2.4.3.2 页表项（PTE）的同步更新](#2432-页表项pte的同步更新)
    - [2.4.3.3 预热顺序与缓存局部性优化](#2433-预热顺序与缓存局部性优化)
    - [2.4.3.4 预热的实现方式](#2434-预热的实现方式)
  - [2.4.4 专用 DPU](#244-专用-dpu)
    - [2.4.4.1 DPU 角色](#2441-dpu-角色)
    - [2.4.4.2 故障恢复](#2442-故障恢复)
  - [2.4.5 CPU 兼容](#245-cpu-兼容)
  - [2.4.6 显式协同模型](#246-显式协同模型)
  - [2.4.7 未来定制 CPU](#247-未来定制-cpu)


---

## 2.4.1 TLB 驱动的作用域访问控制

在 EDSOS 中，内存安全与作用域隔离不依赖运行时的软件检查，而是通过页表项（Page Table Entry, PTE）的权限配置与 MMU 的 TLB 层次结构协同实现。该机制将硬件地址转换过程直接转化为作用域访问控制的执行基础，确保合法访问高效完成，非法访问必然触发可捕获的异常。

### 2.4.1.1 页表项的二元状态设计

EDSOS 为页表项定义两种互斥状态，以精确表达 AS 节点的作用域语义：

- **作用域内页**（In-Scope Pages）：  
  对应当前运行 AS 节点及其所有直系祖先节点所映射的虚拟页。其 PTE 被设置为可读、可写（或可执行），允许节点直接访问。

- **作用域外页**（Out-of-Scope Pages）：  
  对应系统中其余所有内存区域，包括兄弟节点、子孙节点及其他 AS 的节点。其 PTE 被显式标记为无效（`Present = 0`）或无访问权限（如 `User = 0`、`R/W = 0`）。

该二元设计使页表本身成为作用域边界的静态权威定义。任何对作用域外页的访问尝试均会触发 Page Fault，由操作系统异常处理程序捕获。

---

### 2.4.1.2 TLB 层次结构与作用域语义对齐

EDSOS 利用现代处理器的两级 TLB 架构，与 AS 树的层次结构对齐，以兼顾性能与安全性：

- **L1 TLB**：缓存当前 AS 节点自身的页表项。  
  调度器在节点激活前主动预热其所有页至 L1 TLB。由于 L1 TLB 容量有限（通常仅数十项），该设计确保节点对自身数据的访问具有确定性的低延迟，同时天然排除对非自身页的 L1 命中可能。

- **L2 TLB**：缓存当前节点所有直系祖先节点的页表项。  
  调度器同步预热祖先链页至 L2 TLB。L2 TLB 容量较大（通常数百至上千项），足以容纳典型祖先链。节点访问祖先数据时，虽发生 L1 TLB Miss，但可在 L2 TLB 命中，避免 Page Walk 开销。

该对齐策略使 TLB 缓存内容与作用域语义一致：L1 TLB 代表“当前上下文”，L2 TLB 代表“继承上下文”。

---

### 2.4.1.3 异常处理：Page Fault 作为越界信号

当内存访问未命中 L1 与 L2 TLB 时，硬件启动 Page Walk 过程：

- 若访问地址属于作用域内页（PTE 有效），Page Walk 成功，新条目填入 TLB。此为合法冷数据访问，性能有所下降但行为正确。
- 若访问地址属于作用域外页（PTE 无效），Page Walk 失败，硬件触发 Page Fault。

EDSOS 的异常处理程序捕获该 Fault 后，依据页表状态可立即判定访问非法，并对当前 AS 节点及其子树执行 `warn` 操作，将其状态置为 `error` 并触发终止流程。该判断逻辑简单、开销低，确保安全响应的及时性。

---

### 2.4.1.4 边界情况与优雅退化

上述机制依赖于以下工程约束：单个 AS 节点及其祖先链所占虚拟页总数不超过 L1 与 L2 TLB 的联合容量。EDSOS 为此提供明确的退化策略：

- **节点过大**：若节点页数超过 L1 TLB 容量，部分页无法预热至 L1。访问这些页将触发 L2 TLB 命中或 Page Walk，性能下降但安全性不受影响。
- **祖先链过长**：若祖先链总页数超过 L2 TLB 容量，部分祖先页无法预热。为保证功能正确性，这些页的 PTE 仍保持有效，避免合法访问被误判为非法。此时性能退化至传统操作系统水平，但内存安全仍由页表状态保障。

该设计确保 EDSOS 在满足约束时提供确定性高性能，在边界情况下仍能维持功能正确性与基本安全。

---

## 2.4.2 PCID 作为祖链指纹
<TODO>
- TLB 刷新最小化
- 结构变更的缓存一致性

---

## 2.4.3 调度预热机制

在 EDSOS 的硬件协同执行模型中，调度器不仅负责执行流的调度决策，还主动管理 TLB 状态。每次上下文切换均伴随一次 **TLB 预热**（TLB Preheating）操作，其目标是在新 AS 节点开始执行前，将其自身及其直系祖先节点的页表项尽可能预载入 TLB，以实现高效且安全的内存访问。

### 2.4.3.1 预热范围的增量计算：基于最小公共祖先（LCA）

调度器通过增量比较新旧执行节点的祖先链，确定需预热的页面集合，避免重复遍历整棵 AS 树。

- **运行节点直系祖先缓存**（Running Node Direct Ancestors Cache, RNDAC）  
  每个 CPU 核心的调度器维护一个轻量级缓存 RNDAC，按从根到当前运行节点的顺序，存储当前节点的所有直系祖先指针（含自身）。

- **最小公共祖先**（Lowest Common Ancestor, LCA）  
  当调度器准备切换至新节点 $N_{\text{new}}$ 时，从 $N_{\text{new}}$ 向上遍历其祖先链，并在 RNDAC 中查找首个匹配项。该匹配项即为 $N_{\text{old}}$ 与 $N_{\text{new}}$ 的 LCA。

- **增量更新 RNDAC**  
  调度器保留 RNDAC 中从根到 LCA 的部分，并将 $N_{\text{new}}$ 从 LCA 的子节点开始至自身的路径追加或替换至缓存末尾。此过程的时间复杂度为 $O(D)$，其中 $D$ 为 $N_{\text{new}}$ 到 LCA 的距离。由于调度器优先进行结构亲和性调度，$D$ 通常较小。

- **结构变更处理**  
  若直系祖先链发生拓扑变更（例如某节点被 `pivot` 至当前祖链范围内），调度器将主动暂停受影响的运行节点，并同步更新 RNDAC 中对应项，确保缓存与实际结构一致。

需预热的页面集合为：$N_{\text{new}}$ 自身及其从 LCA 的子节点至 $N_{\text{new}}$ 路径上所有节点所映射的虚拟页。

---

### 2.4.3.2 页表项（PTE）的同步更新

在执行 TLB 预热前，调度器确保页表状态与新作用域边界一致：

- 将新作用域内所有页（即 $N_{\text{new}}$ 及其直系祖先节点所映射的页）的 PTE 设置为有效（`Present=1`，权限位正确）；
- 确保作用域外页的 PTE 保持无效（`Present=0` 或无访问权限）。

此步骤保证后续内存访问的合法性完全由页表状态决定，为 TLB 预热和异常处理提供基础。

---

### 2.4.3.3 预热顺序与缓存局部性优化

EDSOS 采用 **从根向叶** 的顺序执行预热操作：

- 从 LCA 的子节点开始，依次向下预热至 $N_{\text{new}}$；
- 此顺序利用现代 CPU TLB 的伪 LRU 替换策略：后预热的条目在 TLB 中“更新鲜”，更不易被替换；
- 由于程序最频繁访问的是当前节点自身数据，其次是直接父节点，将它们最后预热可最大化其在 L1 TLB 中的驻留概率。

该策略尽可能实现理想的 TLB 内容布局，但不强求严格精确对应，允许在 TLB 容量不足时自然退化。

---

### 2.4.3.4 预热的实现方式

调度器对每个需预热的页面执行一次虚拟地址读取操作（例如读取页内首个字节）：

- 该操作触发 MMU 地址转换；
- 由于 PTE 已设为有效，硬件将完成页表遍历（Page Walk，若 TLB 未命中），并将翻译结果安装至 L1/L2 TLB；
- 调度器不等待实际数据加载完成，仅依赖地址转换副作用完成 TLB 填充。

为提升效率，调度器可使用硬件预取（prefetch）指令，并利用 CPU 的自动预取机制，减少显式触发的读操作数量。

---

## 2.4.4 专用 DPU

### 2.4.4.1 DPU 角色
- GVA ↔ LVA 映射
- 一致性协议执行引擎
- 故障检测与恢复代理

### 2.4.4.2 故障恢复
- PM 失效检测：DPU 心跳/超时
- 所有权接管：各个副本自我票选新正本
- 路径自动清理：`dpu_cleanup_pm_refs`

---

## 2.4.5 CPU 兼容
- 页表格式兼容 x86/ARM（PTE 扩展 OS 位）
- TLB 管理：同子树不切换 CR3
- 缺页异常：由调度器处理

---

## 2.4.6 显式协同模型
- **DPU 指令由应用主动触发**，提供相关编译器扩展或插桩器
- **无隐式监听**（无 MMU 旁路）

---

## 2.4.7 未来定制 CPU
- 实现对 EDSOS 的 Node-level 页表兼容
- 主动管理内存访问，适应 SDRAM 作为 L3 Cache 的连接