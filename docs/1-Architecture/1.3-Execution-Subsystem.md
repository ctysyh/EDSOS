<!--
SPDX-FileCopyrightText: © 2025 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 1.3 Execution-Subsystem

---

- [1.3 Execution-Subsystem](#13-execution-subsystem)
  - [**1.3.1 设计愿景与核心原则**](#131-设计愿景与核心原则)
  - [1.3.2 Arbor Strux（AS）进程模型](#132-arbor-struxas进程模型)
    - [1.3.2.1 AS 作为统一执行原语](#1321-as-作为统一执行原语)
      - [1.3.2.1.1 进程即 AS：从抽象到实例](#13211-进程即-as从抽象到实例)
      - [1.3.2.1.2 节点：执行与内存的统一体](#13212-节点执行与内存的统一体)
      - [1.3.2.1.3 节点状态机与操作](#13213-节点状态机与操作)
      - [1.3.2.1.4 AS 的构建：EDSOS Loader 的角色](#13214-as-的构建edsos-loader-的角色)
      - [1.3.2.1.5 与传统进程模型的映射](#13215-与传统进程模型的映射)
    - [1.3.2.2 Meta-AS：系统的全局结构化视图](#1322-meta-as系统的全局结构化视图)
      - [1.3.2.2.1 系统服务的 AS 表达](#13221-系统服务的-as-表达)
      - [1.3.2.2.2 硅中介层：底层执行支持](#13222-硅中介层底层执行支持)
      - [1.3.2.2.3 AS 的生命周期管理](#13223-as-的生命周期管理)
      - [1.3.2.2.4 进程标识与命名](#13224-进程标识与命名)
      - [1.3.2.2.5 基于 CARN 的进程间通信](#13225-基于-carn-的进程间通信)
        - [1.3.2.2.5.1 CARN 的定义](#132251-carn-的定义)
        - [1.3.2.2.5.2 CARN 的操作流程](#132252-carn-的操作流程)
    - [1.3.2.3 系统启动与初始化：从局部到全局的 AS 构建](#1323-系统启动与初始化从局部到全局的-as-构建)
      - [启动约束与地址空间设计](#启动约束与地址空间设计)
      - [阶段一：EDSOS 早期局部视图（Early Local View）](#阶段一edsos-早期局部视图early-local-view)
      - [阶段二：全局 Meta-AS 视图构建](#阶段二全局-meta-as-视图构建)
      - [补充](#补充)
  - [1.3.3 节点调度器架构](#133-节点调度器架构)
    - [1.3.3.1 Per-Core 分布式调度器](#1331-per-core-分布式调度器)
      - [1.3.3.1.1 调度器的组成](#13311-调度器的组成)
      - [1.3.3.1.2 去中心化架构](#13312-去中心化架构)
      - [1.3.3.1.3 调度器的核心职责](#13313-调度器的核心职责)
      - [1.3.3.1.4 调度器与 AS 的关系](#13314-调度器与-as-的关系)
    - [1.3.3.2 调度触发机制](#1332-调度触发机制)
      - [1.3.3.2.1 协作式调度：内联桩函数驱动](#13321-协作式调度内联桩函数驱动)
        - [（1）节点边界桩函数（Entry/Exit Trampolines）](#1节点边界桩函数entryexit-trampolines)
        - [（2）状态操作桩函数](#2状态操作桩函数)
      - [1.3.3.2.2 抢占式调度：硬件中断驱动](#13322-抢占式调度硬件中断驱动)
      - [1.3.3.2.3 链式消息总线的协同要求](#13323-链式消息总线的协同要求)
    - [1.3.3.3 就绪结构：分布式就绪森林（Distributed Ready Forest）](#1333-就绪结构分布式就绪森林distributed-ready-forest)
      - [1.3.3.3.1 每核就绪链表（Per-Core Ready Linked List）](#13331-每核就绪链表per-core-ready-linked-list)
      - [1.3.3.3.2 每核等待图（Per-Core Wait Graph）](#13332-每核等待图per-core-wait-graph)
    - [1.3.3.4 链式消息总线](#1334-链式消息总线)
      - [**1.3.3.4.1 链式可扩展的拓扑结构**](#13341-链式可扩展的拓扑结构)
      - [**1.3.3.4.2 消息的数据结构**](#13342-消息的数据结构)
      - [**1.3.3.4.3 总线调用**](#13343-总线调用)
    - [1.3.3.5 面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）](#1335-面向调度器的信号闭包scheduler-driven-semaphore-closure-sdsc)
      - [SDSC 的定义与生命周期](#sdsc-的定义与生命周期)
      - [SDSC 的内存布局与执行结构](#sdsc-的内存布局与执行结构)
      - [SDSC 的安全约束](#sdsc-的安全约束)
  - [**1.3.4 节点操作与生命周期**](#134-节点操作与生命周期)
    - [**1.3.4.1 原子操作语义**](#1341-原子操作语义)
      - [**1.3.4.1.1 `push`：原子创建，无中间态**](#13411-push原子创建无中间态)
      - [**1.3.4.1.2 `active`：调度器驱动的上下文激活**](#13412-active调度器驱动的上下文激活)
      - [**1.3.4.1.3 `wait`：阻塞与信号驱动唤醒**](#13413-wait阻塞与信号驱动唤醒)
      - [**1.3.4.1.4 `lift`：结构变更，需 yield**](#13414-lift结构变更需-yield)
      - [**1.3.4.1.5 `merge`：扩容操作，需 yield**](#13415-merge扩容操作需-yield)
      - [**1.3.4.1.6 `detach`：分裂操作，需 yield**](#13416-detach分裂操作需-yield)
      - [**1.3.4.1.7 `yield`：中断驱动的上下文冻结**](#13417-yield中断驱动的上下文冻结)
      - [**1.3.4.1.8 `finish`：正常退出**](#13418-finish正常退出)
      - [**1.3.4.1.9 `pop`：父节点回收子节点**](#13419-pop父节点回收子节点)
      - [**1.3.4.1.10 `warn`：安全异常**](#134110-warn安全异常)
    - [1.3.4.2 安全异常处理：`warn` 与子树终止](#1342-安全异常处理warn-与子树终止)
  - [**1.3.5 硬件协同执行模型**](#135-硬件协同执行模型)
    - [1.3.5.1 TLB 驱动的作用域访问控制](#1351-tlb-驱动的作用域访问控制)
      - [1.3.5.1.1 页表项的二元状态设计](#13511-页表项的二元状态设计)
      - [1.3.5.1.2 TLB 层次结构与作用域语义对齐](#13512-tlb-层次结构与作用域语义对齐)
      - [1.3.5.1.3 异常处理：Page Fault 作为越界信号](#13513-异常处理page-fault-作为越界信号)
      - [1.3.5.1.4 边界情况与优雅退化](#13514-边界情况与优雅退化)
    - [**1.3.5.2 PCID 作为祖链指纹**](#1352-pcid-作为祖链指纹)
    - [1.3.5.3 调度预热机制](#1353-调度预热机制)
      - [1.3.5.3.1 预热范围的增量计算：基于最小公共祖先（LCA）](#13531-预热范围的增量计算基于最小公共祖先lca)
      - [1.3.5.3.2 页表项（PTE）的同步更新](#13532-页表项pte的同步更新)
      - [1.3.5.3.3 预热顺序与缓存局部性优化](#13533-预热顺序与缓存局部性优化)
      - [1.3.5.3.4 预热的实现方式](#13534-预热的实现方式)
  - [**1.3.6 同步机制**](#136-同步机制)
    - [1.3.6.1 EDSOS 信号：执行顺序屏障](#1361-edsos-信号执行顺序屏障)
      - [1.3.6.1.1 信号的本质：无实体的调度器提示](#13611-信号的本质无实体的调度器提示)
      - [1.3.6.1.2 同核同步：O(1) 调度器内操作](#13612-同核同步o1-调度器内操作)
      - [1.3.6.1.3 跨核同步：协商式唤醒机制](#13613-跨核同步协商式唤醒机制)
    - [**1.3.6.2 标准同步接口的实现**](#1362-标准同步接口的实现)
  - [**1.3.7 系统调用模型**](#137-系统调用模型)
    - [1.3.7.1 第一类系统调用架构](#1371-第一类系统调用架构)
      - [1.3.7.1.1 定义与核心特征](#13711-定义与核心特征)
      - [1.3.7.1.2 接口分类与具体实现](#13712-接口分类与具体实现)
        - [**1.3.7.1.2.1 调度器 NOI 中可被用户代码直接调用的接口**](#137121-调度器-noi-中可被用户代码直接调用的接口)
        - [**1.3.7.1.2.2 本地元数据查询接口（非 NOI，但属第一类）**](#137122-本地元数据查询接口非-noi但属第一类)
    - [1.3.7.2 第二类系统调用架构](#1372-第二类系统调用架构)
      - [1.3.7.2.1 适用范围界定](#13721-适用范围界定)
      - [1.3.7.2.2 SPN 作为高效通信通道](#13722-spn-作为高效通信通道)
      - [1.3.7.2.3 执行流程](#13723-执行流程)
      - [1.3.7.2.4 安全与性能特性](#13724-安全与性能特性)
    - [**1.3.7.3 兼容模式支持（POSIX / Win32 / Native）**](#1373-兼容模式支持posix--win32--native)
  - [1.3.8 负载均衡](#138-负载均衡)
    - [1.3.8.1 负载均衡的策略与触发条件](#1381-负载均衡的策略与触发条件)
    - [1.3.8.2 去中心化协商机制：基于链式消息总线的请求-响应模型](#1382-去中心化协商机制基于链式消息总线的请求-响应模型)
      - [1.3.8.2.1 主动请求的触发条件](#13821-主动请求的触发条件)
      - [1.3.8.2.2 响应与迁移决策](#13822-响应与迁移决策)
    - [1.3.8.3 子树级迁移](#1383-子树级迁移)
    - [1.3.8.4 代理节点机制：减少跨 Core 通信](#1384-代理节点机制减少跨-core-通信)
      - [1.3.8.4.1 代理根节点（Proxy Root Node）](#13841-代理根节点proxy-root-node)
      - [1.3.8.4.2 代理子节点（Proxy Child Node）](#13842-代理子节点proxy-child-node)
    - [1.3.8.5 AS 感知的均衡策略](#1385-as-感知的均衡策略)
  - [**1.3.9 工程特性与范式总结**](#139-工程特性与范式总结)


---

## **1.3.1 设计愿景与核心原则**
- 执行单元的重新定义：从“线程”到“AS 节点”
- 核心设计哲学
  - 无隐式共享
  - 结构决定可见性
  - 调度器驱动
  - 去中心化与局部自组织
  - 硬件协同与创造性利用
- 与传统执行模型的本质区别

---

## 1.3.2 Arbor Strux（AS）进程模型

### 1.3.2.1 AS 作为统一执行原语

在 EDSOS 中，传统的“进程”概念被重新定义为一棵动态演化的 **Arbor Strux（AS）结构**。该结构完整表达了运行时的控制流、数据流、作用域、生命周期及局部性等执行语义，是 EDSOS 的基本执行原语。

#### 1.3.2.1.1 进程即 AS：从抽象到实例

每个 EDSOS AS 实例在创建时，由 EDSOS Loader 构造一棵初始 AS。该 AS 的根节点具有特殊语义：它承载了传统操作系统中进程控制块（PCB）的全部元信息，并扩展了 EDSOS 特有的元数据，包括：

- 全局唯一的进程标识符（PID）；
- Capability 政策；
- 调度策略；
- 其他系统级属性。

除根节点外，AS 中的所有其他节点均为普通 AS 节点。这些节点无全局标识符，仅通过父子指针在树中定位。该设计消除了传统模型中“线程 ID”“栈指针”“堆段”等离散概念，将其统一为 AS 节点的结构属性。尽管其组织形式在拓扑上类似于 Linux 的 VMA 结构，但在语义内容、操作接口及执行模型上存在本质差异。

#### 1.3.2.1.2 节点：执行与内存的统一体

AS 节点是 EDSOS 中最小的可调度、可执行且可共享的原子单元。每个节点在虚拟地址空间中占据一段连续的虚拟页（Virtual Pages, VPs），并包含三个逻辑段：

- **元数据段**：存储节点类型、大小、祖先路径哈希等信息，由 EDSOS Loader 在加载期生成；
- **指令段**：包含一段符合 EDSOS Standard ABI 的代码流；
- **数据段**：用于存放局部变量、栈帧或逃逸数据。

节点的运行时语义由其内容与上下文共同决定：

- 若包含有效指令段，则可被调度执行，行为类似于协程或函数调用帧；
- 若仅包含数据段（无指令段），则为退化节点，主要用于数据缓存与共享；
- 若为根节点，则同时承担进程元数据容器与 Capability 策略锚点的功能。

该统一模型使 EDSOS 能在同一抽象下支持从微秒级函数调用到长时间运行的并发任务的全谱系执行模式。

#### 1.3.2.1.3 节点状态机与操作

每个 AS 节点的状态由一个五态状态机描述：

| 状态       | 含义                    |
|----------|-------------------------|
| ready    | 就绪，等待调度          |
| running  | 正在执行                |
| blocked    | 阻塞，等待信号          |
| zombie   | 临终，等待父节点回收    |
| error    | 发生安全异常，已终止    |

节点的状态转换及结构变更通过以下十种原子操作实现，均由调度器执行：

| 操作   | 含义                                             |
|--------|--------------------------------------------------|
| push   | 在当前节点下创建一个新叶子节点                   |
| active | 调度器将 ready 节点激活为 running 状态           |
| wait   | running 节点阻塞，等待指定 EDSOS Semaphore       |
| lift   | 将当前节点挂载至更高层祖先下，改变其作用域       |
| merge  | 将当前节点与其子节点合并，扩展虚拟地址空间       |
| detach | 将当前节点的一部分数据分裂为新子节点             |
| yield  | 暂停 running 节点，保存上下文并返回 ready 状态   |
| finish | 节点执行结束，进入 zombie 状态                   |
| pop    | 父节点回收已处于 zombie 状态的子节点             |
| warn   | 触发安全异常，将节点及其子树置为 error 状态      |

所有操作的语义与执行流程详见 §1.3.4 节点操作与生命周期。

#### 1.3.2.1.4 AS 的构建：EDSOS Loader 的角色

AS 的初始结构由 EDSOS Loader 在进程加载阶段构建，流程如下：

1. **解析 ELF 与 Manifest**：  
   提取入口函数、依赖库及 Capability 声明；检查系统调用指令，将合法的 syscall 桩函数内联展开为对应 x64 指令；对非法调用，按策略拒绝加载（默认）或在兼容模式下进行退化替换。

2. **分配虚拟地址与元数据**：  
   请求内存子系统为每个节点分配连续的局部虚拟地址（LVA）；生成 `.edsos_node_meta` 元数据段，记录 `vbase`、`size` 及 `ancestor_path_hint`。

3. **搭建初始树形拓扑**：  
   创建根节点，注入 Capability 与系统资源视图；将主入口函数作为根节点的直接子节点；静态依赖项（如全局变量、初始化函数）按作用域关系组织为子树。

最终，Loader 输出一棵结构完整、作用域明确且可直接调度的 AS，作为该 AS 实例的运行时起点。

#### 1.3.2.1.5 与传统进程模型的映射

| 传统概念         | EDSOS 对应           | 说明                         |
|------------------|----------------------|------------------------------|
| 进程地址空间     | 整棵 AS              | 作用域由树结构隐式限定       |
| 线程             | 可并行调度的 AS 节点 | 支持父子节点并发执行         |
| 栈帧             | AS 节点的数据段      | 大小受 TLB 容量约束          |
| 堆内存           | 退化节点的数据段     | 生命周期由引用计数管理       |
| 进程控制块 (PCB) | AS 根节点            | 包含 Capability 与调度元数据 |

需注意，EDSOS 用户 AS 不进入传统内核态。系统服务（如文件、网络）同样以 AS 形式存在，通过结构共享与信号同步协作。AS 可包含一个 **SPN（System Proxy Node）** 作为与系统服务通信的代理，详见 §1.3.7 系统调用模型。

---

### 1.3.2.2 Meta-AS：系统的全局结构化视图

EDSOS 采用一种全结构化的系统模型，摒弃了传统操作系统中“内核管理进程”的主从架构。在该模型中，整个运行时系统——包括用户应用、系统服务、设备驱动及安全策略模块——共同构成一棵逻辑上的 **Meta-AS（Meta-Arbor Strux）** 结构。

Meta-AS 并非物理存在的单一数据结构，而是所有 AS 实例在逻辑上的并集。每个 AS 子树代表一个自治的执行上下文，彼此之间通过显式的结构操作（如 CARN 共享、EDSOS Semaphore 同步）进行协作，而非依赖中心化的内核仲裁机制。

#### 1.3.2.2.1 系统服务的 AS 表达

在 EDSOS 中，不存在具有特权层级的“内核进程”。所有功能组件均以 AS 形式实现，并在结构上保持对等：

- **用户 AS**：例如 `/user_a/chrome_instance_01`，表示一个浏览器实例；
- **系统服务 AS**：例如 `/net/sockets`、`/fs/ext4_main`、`/auth/cap_validator`，分别提供网络通信、文件系统和 Capability 验证服务；
- **驱动 AS**：例如 `/drivers/net/e1000`、`/drivers/storage/nvme_ctrl`，直接管理硬件设备。

这些 AS 遵循相同的结构公理：
- 由 AS 节点构成；
- 可被调度器调度；
- 通过 CARN 和 EDSOS Semaphore 与其他 AS 通信。

它们之间的差异仅体现在 Capability 授权范围与硬件访问权限上，而非执行模型本身。该设计在保留微内核安全边界的同时，通过结构化共享避免了传统微内核中因频繁 IPC 导致的性能瓶颈。

#### 1.3.2.2.2 硅中介层：底层执行支持

传统操作系统中由内核提供的基础功能（如内存映射、TLB 管理、上下文切换、中断处理）在 EDSOS 中由 **硅中介层（Silicon Interposer）** 实现。硅中介层具有以下特征：

- 直接运行于裸金属之上；
- 提供调度器、中断响应、内存分配与映射等底层原语；
- 所有 AS 通过加载期 ABI 内联指令直接调用其服务；
- AS 间的通信通过 CARN、链式消息总线和 EDSOS Semaphore 实现。

硅中介层不表现为任何 AS 节点，也不参与逻辑调度。本文档所述的调度器逻辑、内存管理原语及其他底层机制均属于硅中介层的职责范畴。

该设计消除了“陷入内核”的概念：系统调用要么由调度器在本地处理（通过隐式的特权切换），要么通过异步委托交由服务 AS 执行（不在当前 AS 的执行上下文中完成）。

#### 1.3.2.2.3 AS 的生命周期管理

在 EDSOS 中，“创建进程”等价于构造一棵新的 AS 并将其根节点纳入 Meta-AS 的逻辑结构。

**创建流程如下**：
1. 父 AS 调用 `edsos_spawn(manifest_gva)`；
2. 调度器触发 EDSOS Loader，解析目标 ELF 文件与 Capability 清单；
3. Loader 构建初始 AS 结构；
4. 新 AS 的根节点被作为子节点挂载至父节点（或注册到全局命名空间）；
5. 根节点状态被置为 `ready`，等待调度。

**销毁流程如下**：
1. 用户调用 `exit()` 或发生异常终止；
2. 调度器递归执行 `finish` 操作，将整棵 AS 子树置为 `zombie` 状态；
3. 父节点（或全局回收器）执行 `pop` 操作，释放节点内存；
4. 当引用计数归零时，关联的 CARN 自动回收，确保无内存泄漏。

整个生命周期由 AS 结构与引用计数隐式维护，无需全局进程表。

#### 1.3.2.2.4 进程标识与命名

EDSOS 使用 64 位整数 PID 作为 AS 的全局唯一标识符。PID 存储于 AS 根节点中，并可通过全局注册表绑定人类可读名称（如 `/user/chrome_instance_01`）。

AS 的兼容模式标识与 Capability 授权信息在加载阶段写入根节点，并在其整个生命周期内保持不可变。

#### 1.3.2.2.5 基于 CARN 的进程间通信

EDSOS 中的进程间通信（IPC）并非基于消息传递，而是通过 **CARN（Cross AS Referring Node）** 实现的结构化共享内存机制。

##### 1.3.2.2.5.1 CARN 的定义

CARN 是一种特殊的退化 AS 节点，用于在多个 AS 之间建立显式的数据共享连接。其关键特性包括：

- CARN 在每个引用它的 AS 中均作为子节点存在，并遵守该 AS 的结构约束；
- 任一 AS 无法通过 CARN 访问另一 AS 中 CARN 的直系祖先节点，从而维持作用域隔离；
- CARN 仅负责数据共享，不提供并发控制；竞态条件需通过 EDSOS Semaphore 或其他同步机制显式处理；
- 含有指令段的 CARN（如 SPN 及其安全子节点）可用于实现高效通信信道（详见 §1.3.7.2.2）。

##### 1.3.2.2.5.2 CARN 的操作流程

- **创建**：节点 A 执行 `push(CARN_X)`，使 CARN_X 成为其子节点；
- **注册**：CARN_X 被注册至全局命名表（基于分布式哈希表）；
- **提升作用域**：A 执行 `lift(CARN_X)`，使 CARN_X 成为其祖先节点，从而允许后代访问；
- **跨 AS 连接**：
  - 节点 B 通过 `lookup("CARN_X")` 获取其虚拟地址；
  - B 执行 `push(CARN_X_VA, 'as_ctrn')`，随后 `lift(CARN_X)`，使 CARN_X 成为其祖先；
- **断开连接**：任一引用方执行 `pop`，引用计数减一；当引用计数归零时，CARN 被自动释放。

该机制确保了共享内存的安全性与结构一致性。

---

### 1.3.2.3 系统启动与初始化：从局部到全局的 AS 构建

EDSOS 的启动过程并非传统操作系统的“内核接管”模式，而是一个 **分布式、结构化、两阶段的 AS 生长过程**。其核心目标是在保持与通用硬件（CPU、GPU、主板芯片）兼容的前提下，构建跨越多物理机（PM）的统一 Meta-AS 视图。该过程由 **EDSOS 早期局部视图** 与 **全局 Meta-AS 视图** 两个阶段组成。

#### 启动约束与地址空间设计

EDSOS 对通用硬件的控制极为有限，仅能通过私有 DPU（Data Processing Unit）实现扩展。为此，系统定义两种虚拟地址空间：
- **LVA（Local Virtual Address）**：标准 64 位虚拟地址，供通用 CPU 执行与设备 DMA 使用，确保完全兼容现有硬件生态；
- **GVA（Global Virtual Address）**：128 位扩展地址，**仅由 DPU 解析和路由**，对通用硬件透明，用于实现跨 PM 的统一资源访问。

该设计使 EDSOS 能在不修改通用硬件的前提下，构建分布式系统的全局抽象。

#### 阶段一：EDSOS 早期局部视图（Early Local View）

系统首先在每台物理机上加载一个 **过渡性映像**，称为 EDSOS 早期局部视图。此阶段仅运行于单 PM，完成以下任务：
1. **硬件资源发现**：解析 BIOS/UEFI 提供的 ACPI 表，构建本机的局部物理资源树（包括 PCI 设备、MMIO 区域、中断线等）；
2. **DPU 驱动加载**：将 DPU 驱动作为 AS 实例加载并初始化；
3. **配置读取**：从磁盘特定目录（如 `/etc/edsos/configuration.nix`）读取声明式配置，确定系统角色、服务列表、安全策略及集群成员信息；
4. **全局协调准备**：通过 DPU 驱动与其他 PM 的 DPU 通信，参与分布式选举，为后续全局视图构建做准备。

> 此阶段的“局部”指单 PM 的硬件资源集合，即传统意义上的“全局”，但在 EDSOS 语义中仅为全局的子集。

#### 阶段二：全局 Meta-AS 视图构建

当 DPU 网络完成主机编号分配与 Meta-AS 根节点选举后，系统进入全局阶段：
1. **全局资源聚合**：专用系统服务 AS（如 `/hw/resmgr`）通过 DPU 网络收集各 PM 的局部资源树，拼接为 **全局硬件资源视图**；
2. **主机编号管理**：物理机编号由 DPU 网络通过投票机制分配，**仅用于 DPU 路由，对 CPU 透明**，各 PM 无需知晓自身编号；
3. **驱动 AS 启动**：各设备驱动作为 AS 实例启动，通过 SPN 向 `/hw/resmgr` 发起第二类系统调用，请求 GVA 映射（即 `ioremap`）；
4. **Capability 策略应用**：驱动与服务的硬件访问权限由其 Capability 策略在加载时固化，确保最小权限原则。

#### 补充

启动过程深度集成执行子系统的核心机制：
- **驱动为 AS**：每个驱动是独立 AS，类似于微内核架构；
- **启动配置**：借鉴 NixOS 的声明式配置思想，实现可复现、可版本控制的系统初始化；这不仅可用于系统整体的启动配置，也可用于每一个 AS 实例初始化时的配置。

---

## 1.3.3 节点调度器架构

### 1.3.3.1 Per-Core 分布式调度器

EDSOS 调度器并非传统操作系统中的内核线程或独立系统进程，而是一套分布于每个 CPU 核心的运行时机制。它由内联指令段与核心本地数据结构共同构成，不占用任何 AS 节点，也不表现为可被调度的执行实体。调度器的存在体现为每个 CPU 核心上一组协同工作的软硬件组件。

#### 1.3.3.1.1 调度器的组成

EDSOS 调度器由以下两部分组成：

- **内联指令段（Trampoline Stubs）**：  
  在进程加载阶段，EDSOS Loader 将调度器接口（如 `edsos_wait`、`edsos_push`、`edsos_yield`）静态内联为只读机器指令，并嵌入用户代码的函数入口或出口位置。这些桩函数直接操作当前核心的调度器数据结构，不可被用户代码篡改或绕过。

- **每核本地数据结构**：  
  每个 CPU 核心维护一组独立的调度状态，包括：
  - **就绪链表（Ready Linked List）**：就绪 AS 节点的多生产者单消费者（MPSC）队列；
  - **等待图（Wait Graph）**：信号名称到阻塞节点列表的映射；
  - **PCID 与 TLB 上下文缓存**；
  - **负载统计信息**（如就绪队列长度、子树归属核心标识等）。

调度器的执行即为这些内联桩函数对本地数据结构的原子操作，其一致性由硬件内存模型与调度器设计共同保障。

#### 1.3.3.1.2 去中心化架构

EDSOS 调度器采用完全去中心化的架构，具体表现为：

- 不存在全局就绪队列、全局调度线程或中心仲裁组件；
- 所有调度决策（除跨核负载均衡外）均在本地核心完成；
- 节点创建（`push`）、阻塞（`wait`）、唤醒（`signal`）等操作仅影响当前核心的数据结构；
- 跨核协作通过链式消息总线异步完成，不阻塞本地调度流程。

该设计使系统具备天然的水平扩展能力：增加 CPU 核心可线性提升调度吞吐量，且无全局锁竞争瓶颈。

#### 1.3.3.1.3 调度器的核心职责

EDSOS 调度器的职责严格限定于执行流控制与 AS 结构维护，具体包括：

- **就绪结构管理**：  
  维护就绪链表，支持 FIFO、紧急插入及依赖感知等多种插入策略。调度顺序在节点入队时确定，实际调度切换为 O(1) 操作。

- **信号驱动同步**：  
  维护等待图，实现 `wait(event)` 与 `signal(event)` 的 O(1) 阻塞与唤醒。

- **节点激活与上下文切换**：  
  执行 `active` 操作：重建祖先链、预热 TLB、切换 CR3 寄存器、跳转至节点入口。

- **AS 结构操作执行**：  
  原子执行 `push`、`pop`、`lift`、`merge`、`detach` 等节点操作，确保 AS 拓扑结构的良定义性。

- **链式消息总线端点**：  
  作为消息总线的接收端，处理跨核信号（如负载迁移请求、远程唤醒信号）。

- **硬件状态协同**：  
  管理 PCID 分配、TLB 刷新、ASC 时间戳采样等，屏蔽底层硬件复杂性。

调度器不包含任何业务逻辑。文件路径解析、Capability 验证、全局资源管理等职责由对应的系统服务 AS（如 VFS、认证服务）承担，并通过 SPN 异步协作完成（见 §1.3.7）。

#### 1.3.3.1.4 调度器与 AS 的关系

调度器与 AS 在逻辑上正交，但在运行时紧密协作：

- **AS 定义执行语义**：包括作用域、结构、生命周期及可见性；
- **调度器决定执行时机**：包括调度顺序、核心亲和性及 TLB 上下文。

调度器通过遍历 AS 节点的父子指针重建祖先链，通过 TLB 预热保障作用域访问安全，并通过 `yield` 与 `active` 操作确保结构变更的原子可见性。简言之，AS 提供语义，调度器提供执行引擎。

---

### 1.3.3.2 调度触发机制

EDSOS 调度器的执行由两类正交机制触发：**协作式调度**与**抢占式调度**。两类机制均通过 EDSOS Loader 在加载阶段静态内联的指令段实现，触发时机与上下文不同，但共享相同的底层调度逻辑。所有调度路径均集成对**链式消息总线**的处理，以维持系统在去中心化架构下的协调一致性。上述接口共同构成调度器的**常态开放接口**（Normal Open Interface, NOI）。

#### 1.3.3.2.1 协作式调度：内联桩函数驱动

协作式调度由 EDSOS Loader 在进程加载阶段将调度桩函数静态内联至用户代码中，分为两类：

##### （1）节点边界桩函数（Entry/Exit Trampolines）

- **触发时机**：在 AS 节点开始执行前（入口）与执行结束后（出口）自动调用，用户代码无法跳过或显式调用。
- **入口桩函数功能**：
  - 递归预热 TLB，依次访问当前节点及其直系祖先节点的热点页；
  - 设置 CPU 时间配额（基于 ASC 截止时间）；
  - 恢复寄存器上下文（若为恢复执行）；
  - 调用 `check()` 处理链式消息总线的入站消息。
- **出口桩函数功能**：
  - 保存寄存器状态（若需后续恢复）；
  - 通知调度器当前节点已结束；
  - 触发调度主逻辑：
    1. 从本地就绪链表头部选取下一就绪节点；
    2. 验证其祖先链的合法性；
    3. 切换 CR3（含 PCID）；
    4. 跳转至下一节点的入口地址；
  - 调用 `check()` 处理链式消息总线的入站消息。

节点边界桩函数是上下文切换的核心路径，确保每次调度均伴随 TLB 预热与跨核消息处理。

##### （2）状态操作桩函数

- **触发时机**：可在节点执行流中任意位置显式调用，例如 `edsos_wait()`、`edsos_push()` 或 `edsos_lift()`。
- **行为**：除执行对应操作外，默认调用 `check()` 处理链式消息总线的入站消息。
- **接口归属**：此类桩函数属于调度器 NOI，可供用户代码直接调用（详见 §1.3.7.1）。

#### 1.3.3.2.2 抢占式调度：硬件中断驱动

当协作式调度无法满足公平性或实时性要求时，调度器通过硬件中断强制介入执行。

- **中断源**包括：
  - 本地定时器中断（CPU 时间片耗尽）；
  - 处理器间中断（IPI），如负载迁移请求或跨核信号唤醒；
  - TLB 一致性中断（远程 TLB 刷新请求）；
  - 安全异常中断（如页错误验证失败、元数据损坏）。

- **中断处理流程**：
  1. 中断向量表跳转至调度器中断处理桩函数；
  2. 保存当前 `running` 节点的完整上下文；
  3. 根据中断类型执行相应操作：
     - 时间片耗尽：将当前节点状态置为 `ready`，并重新加入本地就绪链表尾部；
     - IPI 唤醒：将指定节点从等待图移至就绪链表；
     - 安全异常：将当前节点状态置为 `error`，并递归终止其子树；
  4. 调用 `check()` 处理链式消息总线的入站消息；
  5. 触发调度主逻辑，切换至下一就绪节点。

抢占式调度确保系统在存在阻塞或异常节点时仍具备活性与安全性。

#### 1.3.3.2.3 链式消息总线的协同要求

所有调度触发路径（协作式或抢占式）均强制执行 `check()` 函数，原因如下：

- 链式消息总线采用无中心、可丢包的 SPSC 环形缓冲区设计；
- 消息可靠性依赖接收方持续、频繁地消费入站消息；
- 若某 CPU 核心长时间未调用 `check()`，其入站队列可能溢出，导致跨核协调失效。

因此，EDSOS 将消息处理深度集成至调度路径中，确保负载均衡、信号唤醒等跨核操作在高负载下仍能及时完成。

---

### 1.3.3.3 就绪结构：分布式就绪森林（Distributed Ready Forest）

EDSOS 调度器使用 **分布式就绪森林**（Distributed Ready Forest）作为其核心就绪管理结构。该结构并非单一全局数据结构，而是由所有 CPU 核心各自维护的 **就绪链表**（Ready Linked List）在逻辑上构成的并集。每个核心的就绪链表独立运行，支持灵活的调度策略与结构亲和性优化，共同形成一个去中心化、高可扩展的任务分发机制。

#### 1.3.3.3.1 每核就绪链表（Per-Core Ready Linked List）

每个 CPU 核心维护一个本地的就绪链表。由于单个核心上的调度操作天然串行，链表的插入与弹出无需使用锁或原子指令。

1. **链表项内容**  
   链表中的每一项为指向一个 AS 节点的线性虚拟地址（LVA）。可选地，每项可附带一个元数据指针，用于携带调度提示信息，例如优先级提示（`priority_hint`）或调度策略标识（`scheduling_policy`）。

2. **多策略插入机制**  
   调度器支持三类插入语义，具体策略由调用上下文或节点元数据决定：
   - **尾部插入**（Tail Insertion）：默认策略，保证先进先出（FIFO）的公平性。
   - **头部插入**（Head Insertion）：用于高优先级系统服务节点（如中断处理回调、驱动完成例程），以确保低延迟响应。
   - **智能顺位插入**（Smart Positioning）：基于以下信息动态确定插入位置：
     - 编译器扩展属性（如 `__edsos_depends_on(node_X)` 声明的依赖关系）；
     - EDSOS Loader 解析的启发式元数据（如热点函数标记、I/O 绑定提示）；
     - 运行时优化器反馈（如基于历史执行间隔或缓存命中率的机器学习模型输出）。  
     调度器据此将节点插入至其依赖节点之后、或同类亲和节点附近，以提升 TLB 与缓存重用率。

3. **隐式的“基地核心”绑定**  
   新创建的 AS 节点由当前核心的调度器通过 `push` 操作生成，并自动加入该核心的就绪链表。因此，整个子树的执行默认在创建核心上进行，具有良好的局部性。节点迁移（migration）是显式行为，需通过负载均衡机制触发（参见 §1.3.8）。

#### 1.3.3.3.2 每核等待图（Per-Core Wait Graph）

等待图（Wait Graph）是调度器用于实现 `wait(event)` 与 `signal(event)` 同步原语的信号-节点映射结构。其设计兼顾性能、内存效率与命名空间隔离，由以下三个每核组件构成：

1. **阻塞节点槽位表**（Block Slot Table）  
   - 类型：动态数组 `BlockSlot slots[MAX_SLOAS]`，初始分配 `N₀` 个槽位（例如 64）。
   - 每个 `BlockSlot` 包含：
     - `Node* blocked_nodes[MAX_NODES_PER_SLOT]`：FIFO 队列，初始长度 `M₀`（例如 8）；
     - `uint32_t count`：当前阻塞节点数量；
     - `bool is_global`：标识该槽位是否对应全局信号。
   - **生命周期管理**：
     - 槽位 ID 可复用，其生命周期由引用计数控制。
     - 动态伸缩策略如下：
       - 若某槽位 `count == MAX_NODES_PER_SLOT`，则分配新缓冲区（例如扩容至 2 倍），并迁移指针；
       - 若连续 `T` 个调度周期内 `count < M₀/4`，则缩容；
       - 若所有槽位使用率超过 90%，则 `MAX_SLOAS` 阶段式扩展（例如增加 64）；
       - 若长期空闲槽位占比超过 50%，则收缩 `MAX_SLOAS`。

2. **本地信号名哈希表**（Local Semaphore Name Hash Map）  
   - 类型：哈希表，映射 `local_event_name → local_event_id`。
   - `local_event_name` 为进程内信号名（例如 `"mutex_lock_0x1234"`）；
   - `local_event_id` 从本地 ID 空间分配（例如 0 至 `N₀−1`）；
   - 名称在当前核心内唯一，无需全局注册；
   - 映射在首次调用 `wait()` 时创建，随最后一个阻塞者离开且无待处理信号时回收。

3. **全局信号名哈希表**（Global Semaphore Name Hash Map）  
   - 类型：哈希表，映射 `global_event_name → local_event_id`。
   - `global_event_name` 为全局唯一名（例如 `"io_complete_disk0_blk123"`）；
   - `local_event_id` 从全局 ID 映射空间分配（例如高位设为 1，值域 ≥ 2³¹）；
   - 映射在首次 `lookup()` 时查询全局信号注册表（基于分布式哈希表 DHT），成功后缓存；
   - 生命周期管理策略与本地信号名哈希表一致。

两个哈希表的 `local_event_id` 值域互斥（本地 ID < 2³¹，全局 ID ≥ 2³¹），确保无命名冲突。

---

### 1.3.3.4 链式消息总线

链式消息总线是 EDSOS 节点调度器实现 **去中心化跨核协调** 的核心通信基础设施，无锁、无中心，依赖局部结构与定期消费运行。

#### **1.3.3.4.1 链式可扩展的拓扑结构**

链式消息总线在逻辑上是一张 **有向图**，实现为每个节点维护一组 **数量等于直连通道数** 的 SPSC（Single-Producer Single-Consumer）无锁队列作为消息缓冲区，节点自己作为消费者、**被直连的上一节点** 作为生产者。

每个节点持有数量等同于直连通道数的 **第 i 个方向的下一节点消息缓冲区** 引用，作为 *直连* 的实现。当发送消息时，**直接写入下一个节点的消息缓冲区**。

#### **1.3.3.4.2 消息的数据结构**

消息有固定格式的消息头和动态的消息负载；发送消息时，写入缓冲区的数据是 **完整的消息头结构体**，其中包含包含标签、传播方向、TTL 等内容，以及对应的消息负载指针和长度。

#### **1.3.3.4.3 总线调用**

每个节点必须频繁调用 `check()` 函数以及时处理自己的缓冲区中的消息。这个函数内会遍历自己的所有缓冲区，根据消息标签调用回调表来处理，并根据 TTL 决定是将消息继续传播到下一个节点还是释放，传播方向规定了具体应该传播给哪个节点。

---

### 1.3.3.5 面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）

面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）是 EDSOS 调度器提供的一种轻量级信号响应机制。SDSC 允许具备相应权限的 AS 节点注册一段静态指令片段，当关联的 EDSOS Semaphore 被触发时，调度器直接执行该片段，而无需唤醒并完整调度一个独立节点。该机制适用于高频、低开销的信号处理场景，同时严格遵守作用域安全与最小权限原则。

#### SDSC 的定义与生命周期

SDSC 由具备注册权限的节点主动创建，并绑定至该节点自身。其核心特征如下：

- **触发方式**：与一个 EDSOS Semaphore 绑定。当该信号被 `signal` 时，调度器自动执行对应的 SDSC。
- **参数与返回值**：
  - SDSC 可接受信号触发时携带的附加信息作为输入参数；
  - SDSC 无返回值，执行结束后其寄存器状态与缓存内容被丢弃。
- **执行限制**：SDSC 内部不可调用 `wait` 等待其他信号。
- **生命周期**：SDSC 的生命周期与其绑定节点一致。当绑定节点执行 `finish` 操作时，其所有关联的 SDSC 自动释放。

#### SDSC 的内存布局与执行结构

SDSC 以结构体实例的形式存储于绑定节点的地址空间中，其关键字段包括：

| 字段 | 说明 |
|------|------|
| `type_tag` | 枚举值 `NODE_TYPE_CLOSURE`，用于与普通 AS 节点区分 |
| `if_param` | 布尔值，指示是否需要信号附加参数 |
| `host_node` | 指向绑定节点的指针 |
| `code_start`, `code_length` | 指令段在节点内的起始偏移与长度（字节） |
| `data_start`, `data_length` | 可访问数据段的起始偏移与长度（字节） |

SDSC 使用一个临时的小型运行空间，数据段位于低地址，指令段紧随其后。注册时，指令段中的地址为相对偏移；加载执行时，调度器将其转换为以 `data_start` 为基址的绝对地址。

该 SDSC 描述符的指针被存储在 Wait Graph 中对应信号的唤醒槽位（Wake Slot）内，且排在所有完整 AS 节点之前。当信号被触发时，调度器按以下流程执行：

1. 检查唤醒槽位中的指针，确认其类型为 `NODE_TYPE_CLOSURE`；
2. 验证内存访问合法性：
   - `code_length` 与 `data_length` 不得超过预设上限；
   - 指令段与数据段的总范围不得超过 `data_length + code_length`；
3. 若验证通过，调度器跳转执行 `[code_start, code_start + code_length)` 范围内的指令，并将信号附加信息作为参数传入；
4. 执行完成后，调度器继续处理该信号的其他监听者。

#### SDSC 的安全约束

为确保系统安全性，SDSC 的使用受到以下限制：

- **注册权限**：仅当节点的 SPN 中包含 `CAP_REGISTER_CLOSURE` Capability 时，方可调用 `edsos_register_closure(...)` 注册 SDSC。普通节点默认无此权限。单个节点可注册的 SDSC 数量存在上限。
- **禁止信号嵌套与自触发**：
  - SDSC 内部不可调用 `wait` 等待任何信号；
  - 节点不可 `signal` 自身 SDSC 所监听的信号。
- **数据访问范围显式声明**：
  - 注册时必须明确指定 `data_start` 与 `data_length`；
  - `data_length` 不得超过单页内存大小（通常为 4 KiB）。
- **指令来源与长度限制**：
  - `code_start` 必须指向绑定节点自身的指令段；
  - `code_length` 不得超过 256 字节；
  - 指令序列不得包含函数调用，且其执行权限不得超过绑定节点的权限。
- **参数与返回限制**：
  - 唯一输入为信号触发时的附加信息；
  - 无返回机制，执行状态在指令流结束后立即丢弃。

> 注：仅包含有效指令段的 AS 节点方可注册 SDSC。信号附加信息的格式与语义详见 §1.3.6.1。

---

## **1.3.4 节点操作与生命周期**

### **1.3.4.1 原子操作语义**

#### **1.3.4.1.1 `push`：原子创建，无中间态**

- **语义**：创建新叶子节点，挂载为当前节点的子节点。
- **触发者**：当前 running 节点（如函数调用、线程 spawn）。
- **起始和目标状态**：空内容 → ready。
- **原子性保证**：
  - 内存子系统必须 **一次性分配所有 VPs**；
  - 若 VP 不足 → 返回错误，不创建部分节点；
  - 跨机 push：目标 PM 完成 VP 分配 + 祖先链验证后，才返回成功。
- **并行性**：多个核心可并发 push 不同父节点的子节点，无冲突。
- **无需中间态**。

#### **1.3.4.1.2 `active`：调度器驱动的上下文激活**

- **语义**：将 ready 节点调度到 CPU 核心执行。
- **触发者**：调度器。
- **起始和目标状态**：ready → running。
- **关键点**：
  - **不限于叶子节点**：父子可并行（如协程 + 主线程）；
  - **调度器责任**：
    1. 选择 ready 节点；
    2. 重建其祖先链（通过父指针遍历）；
    3. **增量 TLB 预热**（L1: 自身；L2: 祖先）；
    4. 加载寄存器上下文；
    5. 切换到 running。
- **失败处理**：
  - TLB 预热失败（罕见）→ 标记 error，尝试下一节点；
  - 无 ready 节点 → 进入 idle。
- **并行模型**：同片/跨片核心调度逻辑一致，仅 TLB 预热延迟不同。

#### **1.3.4.1.3 `wait`：阻塞与信号驱动唤醒**

- **语义**：节点主动放弃 CPU，等待某信号（I/O 完成、锁释放等）。
- **起始和目标状态**：running → blocked。
- **实现机制**：
  - 节点调用 `edsos_wait(event_id)`；
  - EDSOS 将节点加入 **event_id 的等待队列**；
  - 状态转为 blocked；
  - 当信号发生，**信号管理器**遍历队列，将节点状态转为 ready。
- **关键要求**：
  - **唤醒必须精准**：避免虚假唤醒（spurious wakeup）；
  - **无竞态**：wait 与 event_signal 需原子协调（通过内存子系统信号总线）。
- **并行性**：多个节点可 wait 同一信号，无冲突。

#### **1.3.4.1.4 `lift`：结构变更，需 yield**

- **语义**：将节点挂载到更高祖先下，改变其作用域。
- **起始和目标状态**：结构变更。
- **无需中间状态**，但需 **yield 所有子孙节点**。
- **详细流程**：
  1. 节点发起 lift(target_ancestor_gva)；
  2. EDSOS 验证 target_ancestor 在 AS 树中（通过 LVA 遍历）；
  3. **暂停所有子孙节点**（递推调用 `yield`）；
  4. 原子更新父指针；
  5. 子孙节点状态仍为 ready，但下次 active 时将使用新祖链。
- **为什么无需 lift_pending**？
  - 因为 **作用域变更对子孙不可见，直到它们被重新调度**；
  - TLB 是 per-core 的，旧核心的 TLB 仍有效，直到被刷新；
  - **安全由调度器保证**：子孙下次运行时，TLB 预热基于新父链。
- **跨机 lift**：跨机传输新挂载点，目标 PM 执行相同 yield + 更新；通过代理根节点（缓存本机子树的根节点之上的信息，接收其他 PM 发来的作用到本机子树根节点的直系祖节点链的结构变更消息）和代理子节点（缓存本机父树的从一个节点开始的子树在其他 PM 的信息，接收其他 PM 发来的从子树向上作用到这个节点的结构变更消息）来在每个 PM 中缓存信息，减少频繁跨机访问开销。

#### **1.3.4.1.5 `merge`：扩容操作，需 yield**

- **语义**：将自身与一个“扩展子节点”合并，扩大虚拟地址范围。
- **起始和目标状态**：结构变更。
- **流程**：
  1. 先 `push` 一个扩展子节点（仅数据段）；
  2. 调用 `merge(child_gva)`；
  3. **yield 自身**（若 running）；
  4. 内存子系统 **虚拟重映射**：将 child 的 VPs 合并到父的地址空间；
  5. 更新 `vbase/size`；
  6. 子节点标记为 zombie；
  7. 自身状态仍为 ready（若原为 ready）或 running（下次调度恢复）。
- **关键**：merge 期间，**自身不能执行**，故需 yield。
- **无需 merge_pending**：因操作在 yield 保护下原子完成。

---

#### **1.3.4.1.6 `detach`：分裂操作，需 yield**

- **语义**：将部分数据分裂为新子节点，用于回收或 Lift。
- **起始和目标状态**：结构变更。
- **流程**：
  1. **yield 自身**；
  2. 内存子系统分配新 VPs；
  3. 迁移数据；
  4. 创建新子节点（状态 ready）；
  5. 更新自身 `vbase/size`；
  6. 恢复状态。
- **典型场景**：冷数据回收 → detach → lift 到全局缓存池。

---

#### **1.3.4.1.7 `yield`：中断驱动的上下文冻结**

- **语义**：将 running 节点暂停，保存上下文，回到 ready。
- **起始和目标状态**：running → ready。
- **触发场景**：
  - 定时器中断（时间片到期）；
  - TLB 一致性中断（跨核 TLB 刷新）；
  - 调度器主动抢占；
  - lift/merge/detach 需要暂停。
- **操作**：
  - 保存寄存器；
  - 状态 → ready；
  - **不清空 TLB**（下次 active 可复用，除非祖链变更）。

---

#### **1.3.4.1.8 `finish`：正常退出**

- **语义**：节点执行完毕，进入 zombie。
- **触发**：`return` 或 `edsos_exit()`。
- **起始和目标状态**：running → zombie。
- **行为**：
  - 若有子节点，**递归 finish**（AS 子树语义）；
  - 父节点可 later `pop`。

---

#### **1.3.4.1.9 `pop`：父节点回收子节点**

- **语义**：父节点显式回收已 zombie 的子节点。
- **起始和目标状态**：zombie → 空内容。
- **原子性**：检查子节点状态 == zombie → 释放内存 → 删除父指针。
- **跨机 pop**：通过代理子节点向对应的远程 PM 中的代理根节点发送 `pop` 消息。

---

#### **1.3.4.1.10 `warn`：安全异常**

- **语义**：强制进入 error 状态，终止子树。
- **起始和目标状态**：any → error。
- **触发**：
  - Page Fault 验证失败（访问非法地址）；
  - 元数据 magic 错误；
  - 签名无效；
  - 其他异常和错误。
- **行为**：
  - 状态 → error；
  - **递归 error 所有子孙**；
  - 上报安全日志；
  - 父节点可选择 ignore 或 terminate。

---

### 1.3.4.2 安全异常处理：`warn` 与子树终止
<TODO>

---

## **1.3.5 硬件协同执行模型**

### 1.3.5.1 TLB 驱动的作用域访问控制

在 EDSOS 中，内存安全与作用域隔离不依赖运行时的软件检查，而是通过页表项（Page Table Entry, PTE）的权限配置与 MMU 的 TLB 层次结构协同实现。该机制将硬件地址转换过程直接转化为作用域访问控制的执行基础，确保合法访问高效完成，非法访问必然触发可捕获的异常。

#### 1.3.5.1.1 页表项的二元状态设计

EDSOS 为页表项定义两种互斥状态，以精确表达 AS 节点的作用域语义：

- **作用域内页**（In-Scope Pages）：  
  对应当前运行 AS 节点及其所有直系祖先节点所映射的虚拟页。其 PTE 被设置为可读、可写（或可执行），允许节点直接访问。

- **作用域外页**（Out-of-Scope Pages）：  
  对应系统中其余所有内存区域，包括兄弟节点、子孙节点及其他 AS 的节点。其 PTE 被显式标记为无效（`Present = 0`）或无访问权限（如 `User = 0`、`R/W = 0`）。

该二元设计使页表本身成为作用域边界的静态权威定义。任何对作用域外页的访问尝试均会触发 Page Fault，由操作系统异常处理程序捕获。

#### 1.3.5.1.2 TLB 层次结构与作用域语义对齐

EDSOS 利用现代处理器的两级 TLB 架构，与 AS 树的层次结构对齐，以兼顾性能与安全性：

- **L1 TLB**：缓存当前 AS 节点自身的页表项。  
  调度器在节点激活前主动预热其所有页至 L1 TLB。由于 L1 TLB 容量有限（通常仅数十项），该设计确保节点对自身数据的访问具有确定性的低延迟，同时天然排除对非自身页的 L1 命中可能。

- **L2 TLB**：缓存当前节点所有直系祖先节点的页表项。  
  调度器同步预热祖先链页至 L2 TLB。L2 TLB 容量较大（通常数百至上千项），足以容纳典型祖先链。节点访问祖先数据时，虽发生 L1 TLB Miss，但可在 L2 TLB 命中，避免 Page Walk 开销。

该对齐策略使 TLB 缓存内容与作用域语义一致：L1 TLB 代表“当前上下文”，L2 TLB 代表“继承上下文”。

#### 1.3.5.1.3 异常处理：Page Fault 作为越界信号

当内存访问未命中 L1 与 L2 TLB 时，硬件启动 Page Walk 过程：

- 若访问地址属于作用域内页（PTE 有效），Page Walk 成功，新条目填入 TLB。此为合法冷数据访问，性能有所下降但行为正确。
- 若访问地址属于作用域外页（PTE 无效），Page Walk 失败，硬件触发 Page Fault。

EDSOS 的异常处理程序捕获该 Fault 后，依据页表状态可立即判定访问非法，并对当前 AS 节点及其子树执行 `warn` 操作，将其状态置为 `error` 并触发终止流程。该判断逻辑简单、开销低，确保安全响应的及时性。

#### 1.3.5.1.4 边界情况与优雅退化

上述机制依赖于以下工程约束：单个 AS 节点及其祖先链所占虚拟页总数不超过 L1 与 L2 TLB 的联合容量。EDSOS 为此提供明确的退化策略：

- **节点过大**：若节点页数超过 L1 TLB 容量，部分页无法预热至 L1。访问这些页将触发 L2 TLB 命中或 Page Walk，性能下降但安全性不受影响。
- **祖先链过长**：若祖先链总页数超过 L2 TLB 容量，部分祖先页无法预热。为保证功能正确性，这些页的 PTE 仍保持有效，避免合法访问被误判为非法。此时性能退化至传统操作系统水平，但内存安全仍由页表状态保障。

该设计确保 EDSOS 在满足约束时提供确定性高性能，在边界情况下仍能维持功能正确性与基本安全。

---

### **1.3.5.2 PCID 作为祖链指纹**
<TODO>
- TLB 刷新最小化
- 结构变更的缓存一致性

### 1.3.5.3 调度预热机制

在 EDSOS 的硬件协同执行模型中，调度器不仅负责执行流的调度决策，还主动管理 TLB 状态。每次上下文切换均伴随一次 **TLB 预热**（TLB Preheating）操作，其目标是在新 AS 节点开始执行前，将其自身及其直系祖先节点的页表项尽可能预载入 TLB，以实现高效且安全的内存访问。

#### 1.3.5.3.1 预热范围的增量计算：基于最小公共祖先（LCA）

调度器通过增量比较新旧执行节点的祖先链，确定需预热的页面集合，避免重复遍历整棵 AS 树。

- **运行节点直系祖先缓存**（Running Node Direct Ancestors Cache, RNDAC）  
  每个 CPU 核心的调度器维护一个轻量级缓存 RNDAC，按从根到当前运行节点的顺序，存储当前节点的所有直系祖先指针（含自身）。

- **最小公共祖先**（Lowest Common Ancestor, LCA）  
  当调度器准备切换至新节点 \( N_{\text{new}} \) 时，从 \( N_{\text{new}} \) 向上遍历其祖先链，并在 RNDAC 中查找首个匹配项。该匹配项即为 \( N_{\text{old}} \) 与 \( N_{\text{new}} \) 的 LCA。

- **增量更新 RNDAC**  
  调度器保留 RNDAC 中从根到 LCA 的部分，并将 \( N_{\text{new}} \) 从 LCA 的子节点开始至自身的路径追加或替换至缓存末尾。此过程的时间复杂度为 \( O(D) \)，其中 \( D \) 为 \( N_{\text{new}} \) 到 LCA 的距离。由于调度器优先进行结构亲和性调度，\( D \) 通常较小。

- **结构变更处理**  
  若直系祖先链发生拓扑变更（例如某节点被 `lift` 至当前祖链范围内），调度器将主动暂停受影响的运行节点，并同步更新 RNDAC 中对应项，确保缓存与实际结构一致。

需预热的页面集合为：\( N_{\text{new}} \) 自身及其从 LCA 的子节点至 \( N_{\text{new}} \) 路径上所有节点所映射的虚拟页。

#### 1.3.5.3.2 页表项（PTE）的同步更新

在执行 TLB 预热前，调度器确保页表状态与新作用域边界一致：

- 将新作用域内所有页（即 \( N_{\text{new}} \) 及其直系祖先节点所映射的页）的 PTE 设置为有效（`Present=1`，权限位正确）；
- 确保作用域外页的 PTE 保持无效（`Present=0` 或无访问权限）。

此步骤保证后续内存访问的合法性完全由页表状态决定，为 TLB 预热和异常处理提供基础。

#### 1.3.5.3.3 预热顺序与缓存局部性优化

EDSOS 采用 **从根向叶** 的顺序执行预热操作：

- 从 LCA 的子节点开始，依次向下预热至 \( N_{\text{new}} \)；
- 此顺序利用现代 CPU TLB 的伪 LRU 替换策略：后预热的条目在 TLB 中“更新鲜”，更不易被替换；
- 由于程序最频繁访问的是当前节点自身数据，其次是直接父节点，将它们最后预热可最大化其在 L1 TLB 中的驻留概率。

该策略尽可能实现理想的 TLB 内容布局，但不强求严格精确对应，允许在 TLB 容量不足时自然退化。

#### 1.3.5.3.4 预热的实现方式

调度器对每个需预热的页面执行一次虚拟地址读取操作（例如读取页内首个字节）：

- 该操作触发 MMU 地址转换；
- 由于 PTE 已设为有效，硬件将完成页表遍历（Page Walk，若 TLB 未命中），并将翻译结果安装至 L1/L2 TLB；
- 调度器不等待实际数据加载完成，仅依赖地址转换副作用完成 TLB 填充。

为提升效率，调度器可使用硬件预取（prefetch）指令，并利用 CPU 的自动预取机制，减少显式触发的读操作数量。

---

## **1.3.6 同步机制**

### 1.3.6.1 EDSOS 信号：执行顺序屏障

在 EDSOS 中，**EDSOS 信号**（EDSOS Semaphore）并非传统操作系统中的内核对象（如 Windows 的 Semaphore 句柄或 Linux 的 futex），而是一种轻量级的、概念性的**执行顺序屏障**。其设计目标是将并发同步从“对共享状态的竞争”转变为“由调度器驱动的显式执行流编排”，从而契合 EDSOS “调度器驱动”与“无隐式共享”的核心原则。

#### 1.3.6.1.1 信号的本质：无实体的调度器提示

EDSOS 信号具有以下核心特征：

- **无实体性**：信号本身不占用内存，不对应任何内核或用户态数据结构，也不存在句柄（HANDLE）。它仅由一个唯一名称（`event_name`）标识。
- **存在性由调度器动态维护**：仅当至少有一个 AS 节点正在等待该信号时，信号才在某个 CPU 核心的调度器 **等待图**（Wait Graph）中拥有一个逻辑槽位。当所有等待者被唤醒且无新等待者注册时，该槽位被回收，信号在系统中逻辑上消失。
- **作用为执行屏障**：调用 `wait(event_name)` 的节点会主动放弃 CPU，并将其自身注册到该信号的等待队列中，执行流在此处暂停。只有当另一执行上下文调用 `signal(event_name)` 时，调度器才会将等待节点从屏障后释放，使其状态转为 `ready`。
- **生命周期自动管理**：信号无需显式创建（如 `CreateSemaphore`）或销毁（如 `CloseHandle`），其生命周期完全由使用情况动态决定，避免资源泄漏。

#### 1.3.6.1.2 同核同步：O(1) 调度器内操作

当 `wait` 与 `signal` 操作发生在同一 CPU 核心时，EDSOS 信号的处理具有确定性低延迟特性，开销接近常数时间。

- **核心数据结构**：每个核心的调度器维护一个本地等待图（参见 §1.3.3.3.2）。
- **`wait` 操作流程**：
  1. 节点执行 `edsos_wait(event_name)`；
  2. 调度器桩函数将节点状态由 `running` 改为 `blocked`；
  3. 调度器在本地等待图中查找或创建对应 `event_name` 的槽位，并将该节点加入其 FIFO 队列；
  4. 调度器触发调度主逻辑，从就绪链表中选择下一就绪节点执行。
- **`signal` 操作流程**：
  1. 节点执行 `edsos_signal(event_name)`；
  2. 调度器桩函数在本地等待图中定位 `event_name` 对应的队列；
  3. 若队列非空，调度器将队列头部（或全部节点，依语义而定）移至本地就绪链表，并将其状态设为 `ready`。

该机制确保在同核同步场景下，EDSOS 提供高效、确定性的同步性能。

#### 1.3.6.1.3 跨核同步：协商式唤醒机制

当 `signal` 与 `wait` 操作位于不同 CPU 核心时，EDSOS 采用**协商式唤醒**（Negotiated Wakeup）机制实现去中心化协调，避免全局锁或集中式信号管理器。

该机制通过 **QUERY/RESPONSE/GRANT** 三步协商流程完成：

1. **QUERY（查询）**：  
   发起 `signal` 的核心（Giver Core）通过链式消息总线广播一条 `QUERY(event_name)` 消息。

2. **RESPONSE（响应）**：  
   每个接收 `QUERY` 的核心检查其本地等待图。若存在该信号的等待者，则回复 `RESPONSE` 消息，内容包括：
   - 本核心 ID；
   - 用于排序的时间戳（通常基于 `RDASC`），以近似实现跨核 FIFO 公平性；
   - 等待队列长度等元数据。

3. **GRANT（授权）**：  
   Giver Core 收集所有 `RESPONSE` 后，依据预定义策略（例如选择时间戳最早的核心）选出一个获胜者（Winner Core），并向其发送 `GRANT(event_name)` 消息。

4. **本地唤醒**：  
   Winner Core 收到 `GRANT` 后，在其本地执行与同核 `signal` 相同的操作：将等待节点从等待图移至就绪链表。

该机制具有以下优势：
- **去中心化**：无单点瓶颈；
- **按需通信**：仅存在等待者的核心参与协商，通信开销与实际需求成正比；
- **近似 FIFO 公平性**：通过 `(core_id, rdtsc)` 对进行全序排序，在跨核场景下提供可接受的公平性；
- **与调度器深度集成**：协商过程通过链式消息总线异步完成，并由调度器的 `check()` 机制定期处理（参见 §1.3.3.4），不阻塞正常调度流程。

--- 

### **1.3.6.2 标准同步接口的实现**
<TODO>
- Mutex / RWLock / Semaphore / Condition Variable 等
- 用户态状态 + Semaphore 同步分离

---

## **1.3.7 系统调用模型**

### 1.3.7.1 第一类系统调用架构

#### 1.3.7.1.1 定义与核心特征

第一类 syscall 是 **由调度器在本地 CPU 核心上直接、同步地完成处理**，且操作的影响范围限定在 **当前 AS 节点自身、其子树内部，或仅涉及只读的元数据查询** 的系统调用。

第一类 syscall 由进程代码按照桩函数形式调用，由 EDSOS Loader 在加载期静态内联展开为机器指令，直接操作调度器本地数据结构（如 Ready Forest, Wait Graph）或读取本地元数据。

#### 1.3.7.1.2 接口分类与具体实现

第一类 syscall 可分为两大类：**属于调度器 NOI（Normal Open Interface）的** 和 **本地元数据查询接口**。

##### **1.3.7.1.2.1 调度器 NOI 中可被用户代码直接调用的接口**

这些接口是用户代码 **主动控制自身执行流和结构** 的主要手段。

- **节点操作 (Node Operations)**：
  - 即 §1.3.4 中定义的节点状态机操作。
- **信号操作 (Semaphore Operations)**：
  - 即 §1.3.6 中定义的信号操作。
- **调度请求 (Scheduling Hints & Control)**：
  - **主动让出/延长**：`edsos_yield()` (触发立即调度) / `edsos_extend_quota(...)` (请求延长当前时间片，调度器根据策略决定是否批准)。
  - **CPU 亲和性与隔离**：`edsos_set_affinity(core_mask)` / `edsos_request_isolation()`。这些调用**不直接绑定**，而是向调度器的负载均衡模块（Work-Stealing++）提供**策略权重提示**，可能影响子树迁移决策。
  - **优先级提示**：`edsos_set_priority_hint(level)`。影响节点在 Ready Linked List 中的**智能顺位插入**位置（见 §1.3.3.3.1）。
- **时钟请求 (Clock Access)**：
  - **低精度时钟**：`edsos_get_coarse_time()`。返回一个模糊化、低分辨率的时钟值，用于非精确计时。
  - **不信任高精度时钟**：`edsos_get_untrusted_time()`。返回基于调度器记录的节点执行时间，并经过**模糊化和偏移处理**的值，旨在**防御时序侧信道攻击**。
  - **信任高精度时钟**：`edsos_get_trusted_time()`。**仅当进程的 Capability 政策允许**时，Loader 才会将此桩函数内联为直接读取硬件 ASC 的指令，否则会默认内联成为不信任高精度时钟。
- **性能查询 (Performance Profiling)**：
  - `edsos_get_execution_time()`: 返回调度器为当前节点记录的**累计 CPU 执行时间**。
  - `edsos_get_cache/TLB_miss_stats()`: 返回由硬件性能计数器（PMC）采样并由调度器聚合的**缓存/TLB Miss 估计值**。这些数据由调度器在上下文切换时采样获得。

##### **1.3.7.1.2.2 本地元数据查询接口（非 NOI，但属第一类）**

这些接口不改变调度器状态，仅用于 **查询** 根节点或 SPN 中的 **应用只读信息**。

- **硬件信息查询 (Hardware Info)**：
  - 查询记录在 SPN 中的硬件注册信息。此数据由 Capability 政策决定，并可在运行时随符合政策的硬件连接/断开而即时更新。此信息 **可能被根权限篡改**，但系统会同时提供一个 `is_info_tampered` 标志位告知应用程序。
- **进程与线程信息查询 (Process/Thread Info)**：
  - `edsos_get_ts_id()`: 返回当前 AS 的全局唯一标识符（PID），该值存储在根节点中。
  - 在兼容模式下，为模拟传统线程模型，`edsos_get_thread_id()` 会返回其所属 AS 的 ID，因为 EDSOS 中不存在独立的“线程”概念。
- **权限查询 (Permission/Capability Query)**：
  - 查询存储在 SPN 中的 **系统服务访问入口**。例如：`edsos_can_access_network()`。

---

### 1.3.7.2 第二类系统调用架构

第二类系统调用用于处理复杂、敏感、耗时或跨作用域的操作。与第一类系统调用的本地同步执行模式不同，第二类系统调用采用**异步委托**机制：调用请求由调度器转发至专用的系统服务组件 AS（如文件服务、网络协议栈），并通过结构化的共享通道 **SPN**（System Proxy Node）完成参数传递与结果返回。该机制是 EDSOS 实现完整操作系统功能的核心路径。

#### 1.3.7.2.1 适用范围界定

第二类系统调用的判定依据为操作的执行语义与安全影响。典型场景包括：

- 所有 I/O 操作（如文件读写、网络通信、设备控制）；
- 资源创建与管理（如创建 CARN 或全局信号对象）；
- 高权限或全局状态变更（如修改系统时间、加载动态模块）；
- 需复杂协议或状态机处理的操作（如数据库事务）。

在 POSIX/Win32 兼容模式下，若启用了弱安全选项，部分本可归为第一类的调用（如 `getpid()`、`clock_gettime()`）会被强制降级为第二类，以确保行为与传统操作系统一致。

综上，任何需由系统服务代表调用者执行并返回结果的操作，均属于第二类系统调用。

此外，该执行流程亦可用于应用 AS 之间的协作：一个 AS 可通过注册表服务组件公开其接口及访问控制回调，使其他 AS 在主动查询并注入后能够调用，但不会在注册时自动注入至其他 AS 的 SPN。

#### 1.3.7.2.2 SPN 作为高效通信通道

SPN（System Proxy Node）是一种特殊的 CARN，用于在调用者 AS 与系统服务组件之间建立安全、高效的异步通信通道。

1. **SPN 的定义与功能**  
   SPN 具备以下核心特性：
   - **参数与返回值缓冲区**：提供调用者与服务组件共享的结构化内存区域，用于传递调用参数和接收返回结果；
   - **信号协调器**：关联一对同步信号（请求信号与响应信号），实现阻塞-唤醒语义；
   - **桩函数载体**：在 AS 加载阶段，EDSOS Loader 根据 Manifest 中声明的 Capability 策略，将第二类系统调用的桩函数逻辑内联展开并注入 SPN 的指令段。应用代码对系统调用的调用最终转化为对 SPN 指令段的直接跳转。

2. **SPN 的挂载拓扑**  
   SPN 的挂载遵循局部性原则：
   - 每个 AS 在每个 CPU 核心上的本地子树根（Local Subtree Root, LSR）——无论是 AS 根节点还是调度器创建的代理根节点——均挂载一个 SPN 作为其直接子节点；
   - 该 SPN 的作用域仅对本地子树内的节点可见。因此，分配至不同核心的同一 AS 节点访问的是不同的 SPN 实例，从根本上避免跨核并发冲突。

3. **SPN 的使用方式**  
   SPN 对应用开发者完全透明：
   - 编译期：应用代码调用标准系统调用接口；
   - 加载期：EDSOS Loader 根据 Capability 策略，将对应桩函数内联展开为对 SPN 指令段的跳转，并注入参数布局逻辑；
   - 运行期：调用者节点执行内联代码，写入参数、触发请求信号、等待响应信号，整个过程表现为一次“看似同步”的函数调用，实则为信号驱动的异步交互。

4. **安全子节点与大数据访问机制**  
   对于涉及大块数据（如文件内容、网络包、GPU 纹理）的操作，SPN 通过**安全子节点**（Secure Child Node）机制扩展：
   - 安全子节点是由系统服务组件 AS 创建并挂载于 SPN 下的特殊 CARN，可包含指令段以实现数据处理逻辑；
   - 安全子节点不在调用者节点的直系祖先链上，因此不可被直接访问，具备隔离性；
   - 为高效访问其数据，EDSOS 提供两种受控机制：
     - **只读映射窗口**：调度器在构建调用者页表时，将安全子节点的数据页以只读权限预热至 TLB，调用者可直接读取；
     - **SDSC 安全访问指令**：服务组件可将对安全子节点的读写操作封装为 SDSC（Scheduler-Driven Semaphore Closure）。当调用者触发访问请求信号时，调度器直接执行该 SDSC 完成数据拷贝或更新。此方式支持安全读写，但并发控制由服务组件自行处理。

#### 1.3.7.2.3 执行流程

第二类系统调用的完整生命周期遵循异步生产者-消费者模型，由调度器与 EDSOS Semaphore 协同驱动：

1. **用户端发起调用**  
   用户代码调用第二类系统调用桩函数（例如 `edsos_file_read(fd, buf, size)`）。EDSOS Loader 已将其展开为写入 SPN 参数缓冲区的指令序列。调用末尾自动执行 `edsos_wait(kpn_response_event)`，将当前节点置为 `blocked` 状态。

2. **服务端触发**  
   参数写入完成后，桩函数通过调度器 NOI（如 `edsos_signal(service_request_event)`）或链式消息总线通知对应系统服务组件 AS。

3. **服务端处理与响应**  
   服务组件 AS 被调度执行后，读取 SPN 中的请求参数并执行操作：
   - 若返回数据量小（如错误码、元数据），直接写入 SPN 的返回值槽位；
   - 若返回数据量大，服务组件创建一个新的 CARN 子节点（含数据段与可选指令段），将其挂载为 SPN 的子节点，并将关键元数据（如长度、句柄）写入 SPN 返回槽位。

4. **用户端唤醒与数据消费**  
   服务组件完成处理后，调用 `edsos_signal(kpn_response_event)` 唤醒阻塞的用户节点。用户节点恢复执行，从 SPN 读取结果或通过安全子节点访问大块数据。

#### 1.3.7.2.4 安全与性能特性

- **安全性**：SPN 的结构化设计实现了最小权限原则。调用者无法访问服务组件的内部状态，服务组件亦无法越权修改调用者内存。
- **性能**：通过零拷贝数据传递、异步非阻塞执行模型及局部性优化，第二类系统调用的开销显著低于传统陷入-返回式系统调用。
- **可组合性**：SPN 作为标准化接口，支持系统服务以微服务形式独立开发、部署与更新，提升系统模块化程度与可维护性。

---

### **1.3.7.3 兼容模式支持（POSIX / Win32 / Native）**

<TODO>

---

## 1.3.8 负载均衡

### 1.3.8.1 负载均衡的策略与触发条件

EDSOS 采用 **Work-Stealing++** 机制实现负载均衡。该机制是对传统工作窃取（Work-Stealing）模型的扩展，其核心目标并非使各 CPU 核心的就绪节点数量绝对均等，而是**最大化结构亲和性、最小化上下文切换开销与跨核通信成本**。Work-Stealing++ 完全去中心化，以 AS 子树为迁移单位，依赖链式消息总线进行核心间协商，并通过代理节点缓存降低协调开销。

调度器持续监控本地负载状态。当满足以下任一条件时，将触发 Work-Stealing++ 流程：

- **子树规模失衡**：某 AS 子树的节点数量超过预设阈值（例如 1024），导致本地调度延迟上升；
- **AS 分散度过高**：同一 AS 的子树分布在三个或更多 CPU 核心上，引发频繁的跨核信号唤醒与 TLB 冷启动；
- **异常负载波动**：通过链式消息总线或处理器间中断（IPI）接收到邻近核心的过载告警（例如就绪队列长度超过高水位线）；
- **性能敏感 AS 争用**：多个性能敏感型 AS（如云游戏主逻辑、实时音视频处理）共享同一核心，导致调度抖动加剧。

EDSOS 不强制追求负载的数值均衡。例如，一个核心运行多个低优先级 AS，而另一核心独占一个高优先级 AS 的状态，可能被视为符合调度目标的配置。

--- 

### 1.3.8.2 去中心化协商机制：基于链式消息总线的请求-响应模型

#### 1.3.8.2.1 主动请求的触发条件

调度器持续监控本地就绪队列长度与 AS 分布状态。满足以下任一条件时，核心将主动发起负载协商请求：

1. **过载状态**：本地就绪队列长度超过高水位阈值（`HIGH_WATERMARK`），此时广播 `TASK_GIVE_REQUEST` 消息，附带以下信息：
  - 可迁移的 AS 子树列表（按结构亲和性排序）；
  - 性能敏感度标签（如“实时”“批处理”）。
  
2. **空闲状态**：本地就绪队列长度低于低水位阈值（`LOW_WATERMARK`），且未收到其他核心的 `TASK_GIVE_REQUEST` 消息，此时广播 `TASK_GET_REQUEST` 消息，附带以下信息：
  - 本核心的空闲容量；
  - 优先接收的 AS 类型（如“计算密集型”“I/O 绑定型”）。

#### 1.3.8.2.2 响应与迁移决策

1. **响应生成**  
   收到 `TASK_GIVE_REQUEST` 或 `TASK_GET_REQUEST` 消息的核心，若具备接收或提供任务的能力，则回复 `STEAL_OFFER` 消息，内容包括：
   - 本核心的当前空闲容量；
   - 本地已调度的 AS 数量；
   - 其他用于迁移决策的辅助信息（如 NUMA 节点归属、当前运行的 AS 类型）。

2. **迁移决策**  
   请求方（Giver）收集所有 `STEAL_OFFER` 后，依据以下策略选择目标核心（Taker）：
   - 优先选择与 Giver 位于同一 NUMA 域的核心；
   - 若迁移子树属于性能敏感型 AS，则选择当前 AS 数量较少且未运行其他关键 AS 的核心；
   - 否则，选择空闲容量最大的核心。

3. **迁移指令下发**  
   决策完成后，Giver 通过链式消息总线向选定的 Taker 发送 `MIGRATE_SUBTREE(subtree_root_gva, target_core)` 指令，启动子树迁移流程。

整个协商过程通过链式消息总线异步完成，不阻塞本地调度器的正常调度操作。

---

### 1.3.8.3 子树级迁移

EDSOS 的负载均衡机制以 **完整的 AS 子树** 为基本迁移单位。迁移操作必须包含以某一节点为根的全部后代节点，禁止仅迁移部分子孙节点（即“断枝”迁移）。

采用子树作为迁移单位主要基于以下两点技术约束：

1. **TLB 亲和性保障**：AS 子树内的所有节点共享相同的祖先链。迁移完整子树后，目标核心可一次性预热整条祖先链的 TLB 条目，确保作用域内内存访问的高效性与安全性。
2. **信号局部性维护**：若子树内多个节点等待同一 EDSOS Semaphore，拆分迁移将导致跨核心唤醒，增加链式消息总线通信开销并降低同步效率。

因此，调度器在执行迁移前会验证子树结构的完整性，确保迁移操作不会破坏 AS 的拓扑语义。

子树迁移由源核心（Giver）与目标核心（Taker）协同完成，具体步骤如下：

1. **暂停子树执行**：Giver 调度器对整棵待迁移子树执行 `yield` 操作，将其所有节点状态置为 `ready` 并保存上下文。
2. **传输元数据**：通过链式消息总线，Giver 向 Taker 发送子树根节点的线性虚拟地址（LVA）及子树拓扑信息。
3. **更新归属信息**：子树中所有节点的 `subtree_home_core` 字段被更新为目标核心 ID。
4. **接入目标就绪链表**：Taker 调度器将子树根节点加入其本地就绪链表，后续调度将按常规流程激活子树内节点。

迁移过程不涉及节点内存内容的复制，仅转移调度上下文与核心归属，实现 **数据零拷贝** 。节点的虚拟地址空间保持不变，页表映射由硅中介层在跨核心调度时按需重建。

--- 

### 1.3.8.4 代理节点机制：减少跨 Core 通信

为减少同一 AS 分散在多个 CPU 核心时的协调开销，EDSOS 引入 **代理节点缓存机制**。该机制通过在本地缓存远程子树或祖先链的关键结构信息，避免频繁的全局查询与跨核同步，适用于同一处理器内不同核心之间以及跨物理节点（PM）的场景。

#### 1.3.8.4.1 代理根节点（Proxy Root Node）

当某核心上运行的 AS 子树的上游祖先节点位于其他核心时，调度器在该核心上创建一个**代理根节点**，用于缓存从本地子树根节点向上直至 AS 全局根节点的祖先链信息。

代理根节点的主要用途包括：
- 支持 TLB 预热过程中对完整祖先链的遍历；
- 为 Capability 验证提供必要的上下文；
- 接收来自上游核心的结构变更消息（如 `lift` 或 `merge` 操作影响到祖先链）。

代理根节点不包含实际执行逻辑，仅作为结构元数据的只读缓存。

#### 1.3.8.4.2 代理子节点（Proxy Child Node）

当某核心上的 AS 节点将一个子树迁移至其他核心后，调度器在原核心上创建一个**代理子节点**，用于缓存该子树在目标核心上的结构信息。

代理子节点的主要用途包括：
- 为跨核信号信号（`signal`）提供路由信息，确保信号能正确投递至目标子树；
- 接收来自下游核心的结构变更通知（如子树内部发生 `detach` 或 `finish` 操作）。

与代理根节点类似，代理子节点亦为只读缓存，不参与执行或调度。

---

### 1.3.8.5 AS 感知的均衡策略

EDSOS 将 AS 分为两类，采用差异化调度策略：

| AS 类型 | 示例 | 调度策略 |
|--------|------|----------|
| **性能敏感型** | 云游戏主逻辑、实时控制 | 尽量独占 Core，避免与其他 AS 共享 |
| **性能不敏感型** | Capability 鉴权、注册表服务 | 多个可共用同一 Core，主动承担上下文切换开销 |

调度器通过节点中的 `perf_sensitivity` 标签识别类型，并在 Work-Stealing++ 决策中加权。

---

## **1.3.9 工程特性与范式总结**
- 性能：百万级节点、百纳秒调度、零拷贝 IPC
- 安全：作用域隔离、Capability 固化、无用户态竞态
- 可扩展：同核 → 多核 → 跨 CPU → 跨 PM 无缝扩展
- 调试性：全状态可见（Wait Graph、CARN 拓扑、消息流）
- 范式创新：
  - 并发 = 执行顺序的显式编排
  - 进程 = 动态演化的 AS 实例
  - 操作系统 = 超AS 结构的活体系统
