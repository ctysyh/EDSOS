<!--
SPDX-FileCopyrightText: © 2025 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 2.2 Distributed Memory Protocol

---

> v0.1.3-drafting

---

- [2.2 Distributed Memory Protocol](#22-distributed-memory-protocol)
  - [2.2.1 路径缓存协议](#221-路径缓存协议)
    - [适用场景](#适用场景)
    - [机制](#机制)
      - [分布式自动路由](#分布式自动路由)
      - [版本与确认](#版本与确认)
  - [2.2.2 所有权协议](#222-所有权协议)
    - [适用场景](#适用场景-1)
    - [机制](#机制-1)
      - [请求](#请求)
      - [仲裁](#仲裁)
      - [所有权与数据迁移](#所有权与数据迁移)
      - [元数据确认与路径缓存更新](#元数据确认与路径缓存更新)
      - [约束](#约束)


---

## 2.2.1 路径缓存协议

### 适用场景

高频读优化、乐观并发共享、页范围原子操作

### 机制

- 控制流的分支迁移到另一个 PM, 随之带来进程空间的扩张
- 数据流伴随控制流迁移, 新 PM 触发 `ref` 并拷贝获取整个 VP, 在 `ref` 建立过程中建立路径缓存
- 路径缓存的 MidPoint 缓存 (保存在沿路的 DPU 中) 包括 VP 的正本 GVA, 归属的副本 bit_map, HostPoint 方向最近一跳, EndPoint 方向最近一跳; HostPoint 缓存额外包括归属副本 bit_map 所对应的 PM; EndPoint 缓存额外包括正本所在的 PM

#### 分布式自动路由

完全通过路径缓存记录下对应于 VP 的一致性消息的路由方向, 由路径缓存解析器 (PCAU, Path Caching Analysis Unit) 负责解析, 不需中心目录, 只需 GVA 即可自动导向正确的 PM

#### 版本与确认

`RefReq` / `RefAck` 及其他成对指令对应携带相同的由新 PM 生成 (在新 PM 范围内单调增) 的Transaction ID, 旧 PM 在 `RefReq` 时缓存, 在 `RefAck` 时删除; 同时指令携带 TTL, 超时废弃并报告

- 新 PM (非 owner_pm) 触发写操作时, `SWReq (Submit Write)` 指令伴随 Write-Update 沿缓存路径传播到达 owner_pm, owner_pm 触发 `WUReq` (对于小数据) 或 `WIReq` (对于大数据) 携带触发者的 bit_map, 由 PCAU 自动向其他副本转发 & 向触发者返回 `SWAck`, 仍由 PCAU 自动缓存 Transaction ID 并在其他副本全部返回 `WUAck` / `WIAck` 时向主机返回 `WUAck` / `WIAck`
- 旧 PM (owner_pm) 触发写操作时, 直接触发 `WUReq` (对于小数据) 或 `WIReq` (对于大数据); 这里实际上意味着 owner_pm 类似于 MESIF 中的 Forward
- 任何非 owner_pm 触发读操作时需要检查是否有 `Invalid` 标记, 如果是则触发 `ReadReq` 从 owner_pm 处读取得到*已知最新*的版本; 不对数据 (VP) 本身记录版本, 只对一致性协议消息记录版本
- 当控制流退出一个 PM 时, 进程空间随之收缩, 触发 `UnrefReq` 自动清理路径, 但必须等待 `UnrefAck` 才能安全退出

---

## 2.2.2 所有权协议

### 适用场景

实现强一致性读写 / 分布式锁 / 迁移

### 机制

#### 请求

在建立了基于路径缓存的 `ref` 之后, 控制流可以主动触发 `OwnReq`; 当旧 owner_pm 发现自己不再是 owner_pm 时, 也可以根据对应的 Config Tag 寄存器在要求 "始终按照所有者身份读写" 时自动触发 `OwnReq`; 触发之后请求者需要锁定本地的副本 VP, 拒绝新的 store

#### 仲裁

`OwnReq` 到达当前 owner_pm 后触发仲裁流程, 仲裁主要基于指令传播到达的先后顺序（包括自竞争指令）; 只有当多个指令在同一个时钟周期同时到达时, 根据可交换标识 & 租期状态 / 优先级 / 公平防饿 / 端口序号仲裁出归属; 不论是否获得所有权, 都会*立即*（固定的时钟周期数量）返回一个响应 (`OwnAck` / `OwnFail`); 仲裁发生在当前 owner_pm, 它拥有最高的权限, 可以将一个指定的寄存器置高来声明处于"不可被换出状态", 但是这个状态会在DPU内硬件计时, 不可超出上限, "超出上限主机未响应"是一个触发报告主机故障的场景

#### 所有权与数据迁移

当 owner_pm 的仲裁器给出仲裁允许转移和请求方收到 `OwnAck` 时, 各自向 PCAU 提交一个 `Stall`, 一切在此期间到达的 VP 一致性消息都临时写入缓存等待; 同时 owner_pm 并行地在主机本地对 LVA 标记缺页; 请求方在收到 `OwnAck` 时消息附加完整的正本内容, 直接 DMA 写入原副本 VP 对应的 PP中; 接收完成 (接收字节量 & ECC 校验) 后请求方返回 `ROAck (Receive Owning)`, 附带完整的旧副本元数据

#### 元数据确认与路径缓存更新

原 owner_pm 收到 `ROAck` 后更新本机的 GVA 和 LVA 页表项, 并重置与 owner_pm 相关的寄存器, 完成后发送一个特殊的 `PCEReq (Path Caching Exchange)` 要求 MidPoint 中的路径缓存交换方向并附带 HostPoint 所需的额外数据; 请求方收到 `PCEReq` 说明路径缓存的 MidPoint 更新完成, 触发 `PCEAck` 附带 EndPoint 的额外数据, 交换双方的 HostPoint / EndPoint 标记, 消除 PCAU 的 `Stall`, 恢复运行

#### 约束
  - 防止未完成写或本机原子操作期间转移
  - 防止转移期间写
  - 防止租期内转移