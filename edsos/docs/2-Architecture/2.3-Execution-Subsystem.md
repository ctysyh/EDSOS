<!--
SPDX-FileCopyrightText: © 2025 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 2.3 Execution Subsystem

---

> v0.1.3

---

- [2.3 Execution Subsystem](#23-execution-subsystem)
  - [2.3.0 设计愿景与核心原则](#230-设计愿景与核心原则)
  - [2.3.1 执行模型的实现](#231-执行模型的实现)
    - [2.3.1.1 AS 的实现](#2311-as-的实现)
      - [2.3.1.1.1 AS 的构建：EDSOS Loader 的角色](#23111-as-的构建edsos-loader-的角色)
      - [2.3.1.1.2 AS 的生命周期管理](#23112-as-的生命周期管理)
      - [2.3.1.1.3 AS 实例标识与命名](#23113-as-实例标识与命名)
    - [2.3.1.2 基于 CARN 的 AS 实例间通信](#2312-基于-carn-的-as-实例间通信)
      - [2.3.1.2.1 CARN 的定义](#23121-carn-的定义)
      - [2.3.1.2.2 CARN 的操作流程](#23122-carn-的操作流程)
    - [2.3.1.3 系统启动与初始化：从局部到全局的 AS 构建](#2313-系统启动与初始化从局部到全局的-as-构建)
      - [2.3.1.3.1 启动约束与地址空间设计](#23131-启动约束与地址空间设计)
      - [2.3.1.3.2 阶段一：EDSOS 早期局部视图（Early Local View）](#23132-阶段一edsos-早期局部视图early-local-view)
      - [2.3.1.3.3 阶段二：全局 Meta-AS 视图构建](#23133-阶段二全局-meta-as-视图构建)
      - [2.3.1.3.4 补充](#23134-补充)
  - [2.3.2 节点调度器架构](#232-节点调度器架构)
    - [2.3.2.1 Per-Core 分布式调度器](#2321-per-core-分布式调度器)
      - [2.3.2.1.1 调度器的组成](#23211-调度器的组成)
      - [2.3.2.1.2 去中心化架构](#23212-去中心化架构)
      - [2.3.2.1.3 调度器的核心职责](#23213-调度器的核心职责)
      - [2.3.2.1.4 调度器与 AS 的关系](#23214-调度器与-as-的关系)
    - [2.3.2.2 调度触发机制](#2322-调度触发机制)
      - [2.3.2.2.1 协作式调度：内联桩函数驱动](#23221-协作式调度内联桩函数驱动)
        - [（1）节点边界桩函数（Entry/Exit Trampolines）](#1节点边界桩函数entryexit-trampolines)
        - [（2）状态操作桩函数](#2状态操作桩函数)
      - [2.3.2.2.2 抢占式调度：硬件中断驱动](#23222-抢占式调度硬件中断驱动)
      - [2.3.2.2.3 链式消息总线的协同要求](#23223-链式消息总线的协同要求)
    - [2.3.2.3 就绪结构：分布式就绪森林（Distributed Ready Forest）](#2323-就绪结构分布式就绪森林distributed-ready-forest)
      - [2.3.2.3.1 每核就绪链表（Per-Core Ready Linked List）](#23231-每核就绪链表per-core-ready-linked-list)
      - [2.3.2.3.2 每核等待图（Per-Core Wait Graph）](#23232-每核等待图per-core-wait-graph)
    - [2.3.2.4 链式消息总线](#2324-链式消息总线)
      - [2.3.2.4.1 链式可扩展的拓扑结构](#23241-链式可扩展的拓扑结构)
      - [**2.3.2.4.2 消息的数据结构**](#23242-消息的数据结构)
      - [**2.3.2.4.3 总线调用**](#23243-总线调用)
  - [2.3.3 同步机制](#233-同步机制)
    - [2.3.3.1 EDSOS 信号：执行顺序屏障](#2331-edsos-信号执行顺序屏障)
      - [2.3.3.1.1 信号的本质：无实体的调度器提示](#23311-信号的本质无实体的调度器提示)
      - [2.3.3.1.2 同核同步：O(1) 调度器内操作](#23312-同核同步o1-调度器内操作)
      - [2.3.3.1.3 跨核同步：协商式唤醒机制](#23313-跨核同步协商式唤醒机制)
    - [2.3.3.2 面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）](#2332-面向调度器的信号闭包scheduler-driven-semaphore-closure-sdsc)
      - [2.3.3.2.1 SDSC 的定义与生命周期](#23321-sdsc-的定义与生命周期)
      - [2.3.3.2.2 SDSC 的内存布局与执行结构](#23322-sdsc-的内存布局与执行结构)
      - [2.3.3.2.3 SDSC 的安全约束](#23323-sdsc-的安全约束)
  - [2.3.4 负载均衡](#234-负载均衡)
    - [2.3.4.1 负载均衡的策略与触发条件](#2341-负载均衡的策略与触发条件)
    - [2.3.4.2 去中心化协商机制：基于链式消息总线的请求-响应模型](#2342-去中心化协商机制基于链式消息总线的请求-响应模型)
      - [2.3.4.2.1 主动请求的触发条件](#23421-主动请求的触发条件)
      - [2.3.4.2.2 响应与迁移决策](#23422-响应与迁移决策)
    - [2.3.4.3 子树级迁移](#2343-子树级迁移)
    - [2.3.4.4 代理节点机制：减少跨 Core 通信](#2344-代理节点机制减少跨-core-通信)
      - [2.3.4.4.1 代理根节点（Proxy Root Node）](#23441-代理根节点proxy-root-node)
      - [2.3.4.4.2 代理子节点（Proxy Child Node）](#23442-代理子节点proxy-child-node)
    - [2.3.4.5 AS 感知的均衡策略](#2345-as-感知的均衡策略)


---

## 2.3.0 设计愿景与核心原则

- 核心设计哲学
  - 无隐式共享
  - 结构决定可见性
  - 调度器驱动
  - 去中心化与局部自组织
  - 硬件协同与创造性利用
- 与传统执行模型的本质区别
  - 建立在完善的理论模型之上
  - 强结构性、可验证性
  - 更低层次、更加硬件亲和，适应当前硬件特性

---

## 2.3.1 执行模型的实现

### 2.3.1.1 AS 的实现

#### 2.3.1.1.1 AS 的构建：EDSOS Loader 的角色

AS 的初始结构由 EDSOS Loader 在 AS 实例加载阶段构建，流程如下：

1. **解析 ELF 与 Manifest**：  
   提取入口函数、依赖库及 Capability 声明；检查系统调用指令，将合法的 syscall 桩函数内联展开为对应 x64 指令；对非法调用，按策略拒绝加载（默认）或在兼容模式下进行退化替换；库依赖遵循 Arxil 的 `.arxlib` 规范。

2. **分配虚拟地址与元数据**：  
   请求内存子系统为每个节点分配连续的局部虚拟地址（LVA）；生成 `.edsos_node_meta` 元数据段，记录 `vbase`、`size` 及 `ancestor_path_hint`。

3. **搭建初始树形拓扑**：  
   创建根节点，注入 Capability 与系统资源视图；将主入口函数作为根节点的直接子节点；静态依赖项（如全局变量、初始化函数）按作用域关系组织为子树。

最终，Loader 输出一棵带有完整根节点和初始普通节点、可直接调度的 AS 实例作为运行时起点。

#### 2.3.1.1.2 AS 的生命周期管理

在 EDSOS 中，“创建进程”等价于构造一棵新的 AS 并将其根节点纳入 Meta-AS 的逻辑结构。

**创建流程如下**：
1. 父 AS 调用 `edsos_spawn(manifest_gva)`；
2. 调度器触发 EDSOS Loader，解析目标 ELF 文件与 Capability 清单；
3. Loader 构建初始 AS 结构；
4. 新 AS 的根节点被作为子节点挂载至父节点（或注册到全局命名空间）；
5. 根节点状态被置为 `ready`，等待调度。

**销毁流程如下**：
1. 用户调用 `exit()` 或发生异常终止；
2. 调度器递归执行 `finish` 操作，将整棵 AS 子树置为 `zombie` 状态；
3. 父节点（或全局回收器）执行 `pop` 操作，释放节点内存；
4. 当引用计数归零时，关联的 CARN 自动回收，确保无内存泄漏。

整个生命周期由 AS 结构与引用计数隐式维护，无需全局进程表。

#### 2.3.1.1.3 AS 实例标识与命名

EDSOS 使用 64 位整数 ASID 作为 AS 实例的全局唯一标识符。ASID 存储于对应 AS 实例根节点中，由专门系统资源管理服务 AS 分配并记录在全局注册表，可绑定人类可读名称（如 `/user/chrome_instance_01`）。

AS 的兼容模式标识与 Capability 授权信息在加载阶段写入根节点，并在其整个生命周期内保持不可变。

### 2.3.1.2 基于 CARN 的 AS 实例间通信

EDSOS 通过 **CARN（Cross AS Referring Node）** 实现的结构化共享内存机制，对应用经典 OS 的进程间通信（IPC）。特别地，CARN 仅提供结构化引用通道，并发控制必须通过 EDSOS Semaphore 显式编排。

#### 2.3.1.2.1 CARN 的定义

CARN 是一种特殊的退化 AS 节点，用于在多个 AS 之间建立显式的数据共享连接。其关键特性包括：

- CARN 在每个引用它的 AS 中均作为子节点存在，并遵守该 AS 的结构约束；
- 任一 AS 无法通过 CARN 访问另一 AS 中 CARN 的直系祖先节点，从而维持作用域隔离；
- CARN 仅负责数据共享，不提供并发控制；竞态条件需通过 EDSOS Semaphore 或其他同步机制显式处理。

#### 2.3.1.2.2 CARN 的操作流程

- **创建**：节点 A 执行 `push(CARN_X)`，使 CARN_X 成为其子节点；
- **注册**：CARN_X 被注册至全局命名表（基于分布式哈希表）；
- **提升作用域**：A 执行 `lift(CARN_X)`，使 CARN_X 成为其祖先节点，从而允许后代访问；
- **跨 AS 连接**：
  - 节点 B 通过 `lookup("CARN_X")` 获取其虚拟地址；
  - B 执行 `push(CARN_X_VA, 'as_ctrn')`，随后 `lift(CARN_X)`，使 CARN_X 成为其祖先；
- **断开连接**：任一引用方执行 `pop`，引用计数减一；当引用计数归零时，CARN 被自动释放。

该机制确保了共享内存的安全性与结构一致性。

---

### 2.3.1.3 系统启动与初始化：从局部到全局的 AS 构建

EDSOS 的启动过程并非传统操作系统的“内核接管”模式，而是一个 **分布式、结构化、两阶段的 AS 生长过程**。其核心目标是在保持与通用硬件（CPU、GPU、主板芯片）兼容的前提下，构建跨越多物理机（PM）的统一 Meta-AS 视图。该过程由 **EDSOS 早期局部视图** 与 **全局 Meta-AS 视图** 两个阶段组成。

#### 2.3.1.3.1 启动约束与地址空间设计

EDSOS 必须运行在通用硬件上，仅能通过私有 DPU（Data Processing Unit）实现扩展。为此，系统定义两种虚拟地址空间：
- **LVA（Local Virtual Address）**：标准 64 位虚拟地址，供通用 CPU 执行与设备 DMA 使用，确保完全兼容现有硬件生态；
- **GVA（Global Virtual Address）**：128 位扩展地址，**仅由 DPU 解析和路由**，对通用硬件透明，用于实现跨 PM 的统一资源访问。
两者的具体实现详见 §1.2 Memory Subsystem，由内存子系统提供良构的 LVA 空间供执行子系统使用。

该设计使 EDSOS 能在不修改通用硬件的前提下，构建分布式系统的全局抽象。

#### 2.3.1.3.2 阶段一：EDSOS 早期局部视图（Early Local View）

系统首先在每台物理机上加载一个 **过渡性映像**，称为 EDSOS 早期局部视图。此阶段仅运行于单 PM，完成以下任务：
1. **硬件资源发现**：解析 BIOS/UEFI 提供的 ACPI 表，构建本机的局部物理资源树（包括 PCI 设备、MMIO 区域、中断线等）；
2. **DPU 驱动加载**：将 DPU 驱动作为 AS 实例加载并初始化；
3. **配置读取**：从磁盘特定目录（如 `/etc/edsos/configuration.nix`）读取声明式配置，确定系统角色、服务列表、安全策略及集群成员信息；
4. **全局协调准备**：通过 DPU 驱动与其他 PM 的 DPU 通信，参与分布式选举，为后续全局视图构建做准备。

> 此阶段的“局部”指单 PM 的硬件资源集合，即传统意义上的“全局”，但在 EDSOS 语义中仅为全局的子集。

#### 2.3.1.3.3 阶段二：全局 Meta-AS 视图构建

当 DPU 网络完成主机编号分配与 Meta-AS 根节点选举后，系统进入全局阶段：
1. **全局资源聚合**：专用系统服务 AS（如 `/hw/resmgr`）通过 DPU 网络收集各 PM 的局部资源树，拼接为 **全局硬件资源视图**；
2. **主机编号管理**：物理机编号由 DPU 网络通过投票机制分配，**仅用于 DPU 路由，对 CPU 透明**，各 PM 无需知晓自身编号；
3. **驱动 AS 启动**：各设备驱动作为 AS 实例启动，通过 SPN（System Proxy Node，详见 §2.5.2.2） 向 `/hw/resmgr` 发起第二类系统调用，请求 GVA 映射（即 `ioremap`）；
4. **Capability 策略应用**：驱动与服务的硬件访问权限由其 Capability 策略在加载时固化，确保最小权限原则。

#### 2.3.1.3.4 补充

启动过程深度集成执行子系统的核心机制：
- **驱动为 AS**：每个驱动是独立 AS，类似于微内核架构；
- **启动配置**：借鉴 NixOS 的声明式配置思想，实现可复现、可版本控制的系统初始化；这不仅可用于系统整体的启动配置，也可用于每一个 AS 实例初始化时的配置。

---

## 2.3.2 节点调度器架构

### 2.3.2.1 Per-Core 分布式调度器

EDSOS 调度器并非传统操作系统中的内核线程或独立系统进程，而是一套分布于每个 CPU 核心的运行时机制。它由内联指令段与核心本地数据结构共同构成，不占用任何 AS 节点，也不表现为可被调度的执行实体。调度器的存在体现为每个 CPU 核心上一组协同工作的软硬件组件。

#### 2.3.2.1.1 调度器的组成

EDSOS 调度器由以下两部分组成：

- **内联指令段（Trampoline Stubs）**：  
  在 AS 实例加载阶段，EDSOS Loader 将调度器接口（如 `edsos_wait`、`edsos_push`、`edsos_yield`）静态内联为只读机器指令，并嵌入用户代码的函数入口或出口位置。这些桩函数直接操作当前核心的调度器数据结构，不可被用户代码篡改或绕过。

- **每核本地数据结构**：  
  每个 CPU 核心维护一组独立的调度状态，包括：
  - **就绪链表（Ready Linked List）**：就绪 AS 节点的多生产者单消费者（MPSC）队列；
  - **等待图（Wait Graph）**：信号名称到阻塞节点列表的映射；
  - **PCID 与 TLB 上下文缓存**；
  - **负载统计信息**（如就绪队列长度、子树归属核心标识等）。

调度器的执行即为这些内联桩函数对本地数据结构的原子操作，其一致性由硬件内存模型与调度器设计共同保障。

#### 2.3.2.1.2 去中心化架构

EDSOS 调度器采用完全去中心化的架构，具体表现为：

- 不存在全局就绪队列、全局调度线程或中心仲裁组件；
- 所有调度决策（除跨核负载均衡外）均在本地核心完成；
- 节点创建（`push`）、阻塞（`wait`）、唤醒（`signal`）等操作仅影响当前核心的数据结构；
- 跨核协作通过链式消息总线异步完成，不阻塞本地调度流程。

该设计使系统具备天然的水平扩展能力：增加 CPU 核心可线性提升调度吞吐量，且无全局锁竞争瓶颈。

#### 2.3.2.1.3 调度器的核心职责

EDSOS 调度器的职责严格限定于执行流控制与 AS 结构维护，具体包括：

- **就绪结构管理**：  
  维护就绪链表，支持 FIFO、紧急插入及依赖感知等多种插入策略。调度顺序在节点入队时确定，实际调度切换为 O(1) 操作。

- **信号驱动同步**：  
  维护等待图，实现 `wait(event)` 与 `signal(event)` 的 O(1) 阻塞与唤醒。

- **节点激活与上下文切换**：  
  执行 `active` 操作：重建祖先链、预热 TLB、切换 CR3 寄存器、跳转至节点入口。

- **AS 结构操作执行**：  
  原子执行 `push`、`pop`、`lift`、`merge`、`detach` 等节点操作，确保 AS 拓扑结构的良定义性。

- **链式消息总线端点**：  
  作为消息总线的接收端，处理跨核信号（如负载迁移请求、远程唤醒信号）。

- **硬件状态协同**：  
  管理 PCID 分配、TLB 刷新、ASC 时间戳采样等，屏蔽底层硬件复杂性。

调度器不包含任何业务逻辑。文件路径解析、Capability 验证、全局资源管理等职责由对应的系统服务 AS（如 VFS、认证服务）承担。

#### 2.3.2.1.4 调度器与 AS 的关系

调度器与 AS 在逻辑上正交，但在运行时紧密协作：

- **AS 定义执行语义**：包括作用域、结构、生命周期及可见性；
- **调度器决定执行时机**：包括调度顺序、核心亲和性及 TLB 上下文。

调度器通过遍历 AS 节点的父子指针重建祖先链，通过 TLB 预热保障作用域访问安全，并通过 `yield` 与 `active` 操作确保结构变更的原子可见性。简言之，AS 提供语义，调度器提供执行引擎。

---

### 2.3.2.2 调度触发机制

EDSOS 调度器的执行由两类正交机制触发：**协作式调度**与**抢占式调度**。两类机制均通过 EDSOS Loader 在加载阶段静态内联的指令段实现，触发时机与上下文不同，但共享相同的底层调度逻辑。所有调度路径均集成对**链式消息总线**的处理，以维持系统在去中心化架构下的协调一致性。上述接口共同构成调度器的**常态开放接口**（Normal Open Interface, NOI）。

#### 2.3.2.2.1 协作式调度：内联桩函数驱动

协作式调度由 EDSOS Loader 在 AS 实例加载阶段将调度桩函数静态内联至用户代码中，分为两类：

##### （1）节点边界桩函数（Entry/Exit Trampolines）

- **触发时机**：在 AS 节点开始执行前（入口）与执行结束后（出口）自动调用，用户代码无法跳过或显式调用。
- **入口桩函数功能**：
  - 递归预热 TLB，依次访问当前节点及其直系祖先节点的热点页；
  - 设置 CPU 时间配额（基于 ASC 截止时间）；
  - 恢复寄存器上下文（若为恢复执行）；
  - 调用 `check()` 处理链式消息总线的入站消息。
- **出口桩函数功能**：
  - 保存寄存器状态（若需后续恢复）；
  - 通知调度器当前节点已结束；
  - 触发调度主逻辑：
    1. 从本地就绪链表头部选取下一就绪节点；
    2. 验证其祖先链的合法性；
    3. 切换 CR3（含 PCID）；
    4. 跳转至下一节点的入口地址；
  - 调用 `check()` 处理链式消息总线的入站消息。

节点边界桩函数是上下文切换的核心路径，确保每次调度均伴随 TLB 预热与跨核消息处理。

##### （2）状态操作桩函数

- **触发时机**：可在节点执行流中任意位置显式调用，例如 `edsos_wait()`、`edsos_push()` 或 `edsos_lift()`。
- **行为**：除执行对应操作外，默认调用 `check()` 处理链式消息总线的入站消息。
- **接口归属**：此类桩函数属于调度器 NOI，可供用户代码直接调用（详见 §2.3.4.1）。

#### 2.3.2.2.2 抢占式调度：硬件中断驱动

当协作式调度无法满足公平性或实时性要求时，调度器通过硬件中断强制介入执行。

- **中断源**包括：
  - 本地定时器中断（CPU 时间片耗尽）；
  - 处理器间中断（IPI），如负载迁移请求或跨核信号唤醒；
  - TLB 一致性中断（远程 TLB 刷新请求）；
  - 安全异常中断（如页错误验证失败、元数据损坏）。

- **中断处理流程**：
  1. 中断向量表跳转至调度器中断处理桩函数；
  2. 保存当前 `running` 节点的完整上下文；
  3. 根据中断类型执行相应操作：
     - 时间片耗尽：将当前节点状态置为 `ready`，并重新加入本地就绪链表尾部；
     - IPI 唤醒：将指定节点从等待图移至就绪链表；
     - 安全异常：将当前节点状态置为 `error`，并递归终止其子树；
  4. 调用 `check()` 处理链式消息总线的入站消息；
  5. 触发调度主逻辑，切换至下一就绪节点。

抢占式调度确保系统在存在阻塞或异常节点时仍具备活性与安全性。

#### 2.3.2.2.3 链式消息总线的协同要求

所有调度触发路径（协作式或抢占式）均强制执行 `check()` 函数，原因如下：

- 链式消息总线采用无中心、可丢包的 SPSC 环形缓冲区设计；
- 消息可靠性依赖接收方持续、频繁地消费入站消息；
- 若某 CPU 核心长时间未调用 `check()`，其入站队列可能溢出，导致跨核协调失效。

因此，EDSOS 将消息处理深度集成至调度路径中，确保负载均衡、信号唤醒等跨核操作在高负载下仍能及时完成。

---

### 2.3.2.3 就绪结构：分布式就绪森林（Distributed Ready Forest）

EDSOS 调度器使用 **分布式就绪森林**（Distributed Ready Forest）作为其核心就绪管理结构。该结构并非单一全局数据结构，而是由所有 CPU 核心各自维护的 **就绪链表**（Ready Linked List）在逻辑上构成的并集。每个核心的就绪链表独立运行，支持灵活的调度策略与结构亲和性优化，共同形成一个去中心化、高可扩展的任务分发机制。

#### 2.3.2.3.1 每核就绪链表（Per-Core Ready Linked List）

每个 CPU 核心维护一个本地的就绪链表。由于单个核心上的调度操作天然串行，链表的插入与弹出无需使用锁或原子指令。

1. **链表项内容**  
   链表中的每一项为指向一个 AS 节点的线性虚拟地址（LVA）。可选地，每项可附带一个元数据指针，用于携带调度提示信息，例如优先级提示（`priority_hint`）或调度策略标识（`scheduling_policy`）。

2. **多策略插入机制**  
   调度器支持三类插入语义，具体策略由调用上下文或节点元数据决定：
   - **尾部插入**（Tail Insertion）：默认策略，保证先进先出（FIFO）的公平性。
   - **头部插入**（Head Insertion）：用于高优先级系统服务节点（如中断处理回调、驱动完成例程），以确保低延迟响应。
   - **智能顺位插入**（Smart Positioning）：基于以下信息动态确定插入位置：
     - 编译器扩展属性（如 `__edsos_depends_on(node_X)` 声明的依赖关系）；
     - EDSOS Loader 解析的启发式元数据（如热点函数标记、I/O 绑定提示）；
     - 运行时优化器反馈（如基于历史执行间隔或缓存命中率的机器学习模型输出）。  
     调度器据此将节点插入至其依赖节点之后、或同类亲和节点附近，以提升 TLB 与缓存重用率。

3. **隐式的“基地核心”绑定**  
   新创建的 AS 节点由当前核心的调度器通过 `push` 操作生成，并自动加入该核心的就绪链表。因此，整个子树的执行默认在创建核心上进行，具有良好的局部性。节点迁移（migration）是显式行为，需通过负载均衡机制触发（参见 §2.3.4）。

#### 2.3.2.3.2 每核等待图（Per-Core Wait Graph）

等待图（Wait Graph）是调度器用于实现 `wait(event)` 与 `signal(event)` 同步原语的信号-节点映射结构。其设计兼顾性能、内存效率与命名空间隔离，由以下三个每核组件构成：

1. **阻塞节点槽位表**（Block Slot Table）  
   - 类型：动态数组 `BlockSlot slots[MAX_SLOAS]`，初始分配 `N₀` 个槽位（例如 64）。
   - 每个 `BlockSlot` 包含：
     - `Node* blocked_nodes[MAX_NODES_PER_SLOT]`：FIFO 队列，初始长度 `M₀`（例如 8）；
     - `uint32_t count`：当前阻塞节点数量；
     - `bool is_global`：标识该槽位是否对应全局信号。
   - **生命周期管理**：
     - 槽位 ID 可复用，其生命周期由引用计数控制。
     - 动态伸缩策略如下：
       - 若某槽位 `count == MAX_NODES_PER_SLOT`，则分配新缓冲区（例如扩容至 2 倍），并迁移指针；
       - 若连续 `T` 个调度周期内 `count < M₀/4`，则缩容；
       - 若所有槽位使用率超过 90%，则 `MAX_SLOAS` 阶段式扩展（例如增加 64）；
       - 若长期空闲槽位占比超过 50%，则收缩 `MAX_SLOAS`。

2. **本地信号名哈希表**（Local Semaphore Name Hash Map）  
   - 类型：哈希表，映射 `local_event_name → local_event_id`。
   - `local_event_name` 为 AS 实例内信号名（例如 `"mutex_lock_0x1234"`）；
   - `local_event_id` 从本地 ID 空间分配（例如 0 至 `N₀−1`）；
   - 名称在当前核心内唯一，无需全局注册；
   - 映射在首次调用 `wait()` 时创建，随最后一个阻塞者离开且无待处理信号时回收。

3. **全局信号名哈希表**（Global Semaphore Name Hash Map）  
   - 类型：哈希表，映射 `global_event_name → local_event_id`。
   - `global_event_name` 为全局唯一名（例如 `"io_complete_disk0_blk123"`）；
   - `local_event_id` 从全局 ID 映射空间分配（例如高位设为 1，值域 ≥ 2³¹）；
   - 映射在首次 `lookup()` 时查询全局信号注册表（基于分布式哈希表 DHT），成功后缓存；
   - 生命周期管理策略与本地信号名哈希表一致。

两个哈希表的 `local_event_id` 值域互斥（本地 ID < 2³¹，全局 ID ≥ 2³¹），确保无命名冲突。

---

### 2.3.2.4 链式消息总线

链式消息总线是 EDSOS 节点调度器实现 **去中心化跨核协调** 的核心通信基础设施，无锁、无中心，依赖局部结构与定期消费运行。

#### 2.3.2.4.1 链式可扩展的拓扑结构

链式消息总线在逻辑上是一张 **有向图**，实现为每个节点维护一组 **数量等于直连通道数** 的 SPSC（Single-Producer Single-Consumer）无锁队列作为消息缓冲区，节点自己作为消费者、**被直连的上一节点** 作为生产者。

每个节点持有数量等同于直连通道数的 **第 i 个方向的下一节点消息缓冲区** 引用，作为 *直连* 的实现。当发送消息时，**直接写入下一个节点的消息缓冲区**。

这个拓扑结构与专用 DPU 的接口设计直接对应，使得它可以顺利构建在被专用 DPU 连接的多台 PM 上。同时，这个设计也能够适应现代多核 CPU 的片上网络，使得它在单台 PM 内不同 CPU 核心上的构建也非常自然。

#### **2.3.2.4.2 消息的数据结构**

消息有固定格式的消息头和动态的消息负载；发送消息时，写入缓冲区的数据是 **完整的消息头结构体**，其中包含包含标签、传播方向、TTL 等内容，以及对应的消息负载指针和长度。

<TODO> 消息格式的定义

#### **2.3.2.4.3 总线调用**

每个节点必须频繁调用 `check()` 函数以及时处理自己的缓冲区中的消息。这个函数内会遍历自己的所有缓冲区，根据消息标签调用回调表来处理，并根据 TTL 决定是将消息继续传播到下一个节点还是释放，传播方向规定了具体应该传播给哪个节点。

---

## 2.3.3 同步机制

### 2.3.3.1 EDSOS 信号：执行顺序屏障

在 EDSOS 中，**EDSOS 信号**（EDSOS Semaphore）并非传统操作系统中的内核对象（如 Windows 的 Semaphore 句柄或 Linux 的 futex），而是一种轻量级的、概念性的**执行顺序屏障**。其设计目标是将并发同步从“对共享状态的竞争”转变为“由调度器驱动的显式执行流编排”，从而契合 EDSOS “调度器驱动”与“无隐式共享”的核心原则。

#### 2.3.3.1.1 信号的本质：无实体的调度器提示

EDSOS 信号具有以下核心特征：

- **无实体性**：信号本身不占用内存，不对应任何内核或用户态数据结构，也不存在句柄（HANDLE）。它仅由一个唯一名称（`event_name`）标识。
- **存在性由调度器动态维护**：仅当至少有一个 AS 节点正在等待该信号时，信号才在某个 CPU 核心的调度器 **等待图**（Wait Graph）中拥有一个逻辑槽位。当所有等待者被唤醒且无新等待者注册时，该槽位被回收，信号在系统中逻辑上消失。
- **作用为执行屏障**：调用 `wait(event_name)` 的节点会主动放弃 CPU，并将其自身注册到该信号的等待队列中，执行流在此处暂停。只有当另一执行上下文调用 `signal(event_name)` 时，调度器才会将等待节点从屏障后释放，使其状态转为 `ready`。
- **生命周期自动管理**：信号无需显式创建（如 `CreateSemaphore`）或销毁（如 `CloseHandle`），其生命周期完全由使用情况动态决定，避免资源泄漏。

#### 2.3.3.1.2 同核同步：O(1) 调度器内操作

当 `wait` 与 `signal` 操作发生在同一 CPU 核心时，EDSOS 信号的处理具有确定性低延迟特性，开销接近常数时间。

- **核心数据结构**：每个核心的调度器维护一个本地等待图（参见 §2.3.2.3.2）。
- **`wait` 操作流程**：
  1. 节点执行 `edsos_wait(event_name)`；
  2. 调度器桩函数将节点状态由 `running` 改为 `blocked`；
  3. 调度器在本地等待图中查找或创建对应 `event_name` 的槽位，并将该节点加入其 FIFO 队列；
  4. 调度器触发调度主逻辑，从就绪链表中选择下一就绪节点执行。
- **`signal` 操作流程**：
  1. 节点执行 `edsos_signal(event_name)`；
  2. 调度器桩函数在本地等待图中定位 `event_name` 对应的队列；
  3. 若队列非空，调度器将队列头部（或全部节点，依语义而定）移至本地就绪链表，并将其状态设为 `ready`。

该机制确保在同核同步场景下，EDSOS 提供高效、确定性的同步性能。

#### 2.3.3.1.3 跨核同步：协商式唤醒机制

当 `signal` 与 `wait` 操作位于不同 CPU 核心时，EDSOS 采用**协商式唤醒**（Negotiated Wakeup）机制实现去中心化协调，避免全局锁或集中式信号管理器。

该机制通过 **QUERY/RESPONSE/GRANT** 三步协商流程完成：

1. **QUERY（查询）**：  
   发起 `signal` 的核心（Giver Core）通过链式消息总线广播一条 `QUERY(event_name)` 消息。

2. **RESPONSE（响应）**：  
   每个接收 `QUERY` 的核心检查其本地等待图。若存在该信号的等待者，则回复 `RESPONSE` 消息，内容包括：
   - 本核心 ID；
   - 用于排序的时间戳（通常基于 `RDASC`），以近似实现跨核 FIFO 公平性；
   - 等待队列长度等元数据。

3. **GRANT（授权）**：  
   Giver Core 收集所有 `RESPONSE` 后，依据预定义策略（例如选择时间戳最早的核心）选出一个获胜者（Winner Core），并向其发送 `GRANT(event_name)` 消息。

4. **本地唤醒**：  
   Winner Core 收到 `GRANT` 后，在其本地执行与同核 `signal` 相同的操作：将等待节点从等待图移至就绪链表。

该机制具有以下优势：
- **去中心化**：无单点瓶颈；
- **按需通信**：仅存在等待者的核心参与协商，通信开销与实际需求成正比；
- **近似 FIFO 公平性**：通过 `(core_id, rdtsc)` 对进行全序排序，在跨核场景下提供可接受的公平性；
- **与调度器深度集成**：协商过程通过链式消息总线异步完成，并由调度器的 `check()` 机制定期处理（参见 §2.3.2.4），不阻塞正常调度流程。

---

### 2.3.3.2 面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）

面向调度器的信号闭包（Scheduler-Driven Semaphore Closure, SDSC）是 EDSOS 调度器提供的一种轻量级信号响应机制。SDSC 允许具备相应权限的 AS 节点注册一段静态指令片段，当关联的 EDSOS Semaphore 被触发时，调度器直接执行该片段，而无需唤醒并完整调度一个独立节点。该机制适用于高频、低开销的信号处理场景，同时严格遵守作用域安全与最小权限原则。

#### 2.3.3.2.1 SDSC 的定义与生命周期

SDSC 由具备注册权限的节点主动创建，并绑定至该节点自身。其核心特征如下：

- **触发方式**：与一个 EDSOS Semaphore 绑定。当该信号被 `signal` 时，调度器自动执行对应的 SDSC。
- **参数与返回值**：
  - SDSC 可接受信号触发时携带的附加信息作为输入参数；
  - SDSC 无返回值，执行结束后其寄存器状态与缓存内容被丢弃。
- **执行限制**：SDSC 内部不可调用 `wait` 等待其他信号。
- **生命周期**：SDSC 的生命周期与其绑定节点一致。当绑定节点执行 `finish` 操作时，其所有关联的 SDSC 自动释放。

#### 2.3.3.2.2 SDSC 的内存布局与执行结构

SDSC 以结构体实例的形式存储于绑定节点的地址空间中，其关键字段包括：

| 字段 | 说明 |
|------|------|
| `type_tag` | 枚举值 `NODE_TYPE_CLOSURE`，用于与普通 AS 节点区分 |
| `if_param` | 布尔值，指示是否需要信号附加参数 |
| `host_node` | 指向绑定节点的指针 |
| `code_start`, `code_length` | 指令段在节点内的起始偏移与长度（字节） |
| `data_start`, `data_length` | 可访问数据段的起始偏移与长度（字节） |

SDSC 使用一个临时的小型运行空间，数据段位于低地址，指令段紧随其后。注册时，指令段中的地址为相对偏移；加载执行时，调度器将其转换为以 `data_start` 为基址的绝对地址。

该 SDSC 描述符的指针被存储在 Wait Graph 中对应信号的唤醒槽位（Wake Slot）内，且排在所有完整 AS 节点之前。当信号被触发时，调度器按以下流程执行：

1. 检查唤醒槽位中的指针，确认其类型为 `NODE_TYPE_CLOSURE`；
2. 验证内存访问合法性：
   - `code_length` 与 `data_length` 不得超过预设上限；
   - 指令段与数据段的总范围不得超过 `data_length + code_length`；
3. 若验证通过，调度器跳转执行 `[code_start, code_start + code_length)` 范围内的指令，并将信号附加信息作为参数传入；
4. 执行完成后，调度器继续处理该信号的其他监听者。

#### 2.3.3.2.3 SDSC 的安全约束

为确保系统安全性，SDSC 的使用受到以下限制：

- **注册权限**：仅当节点具有 `CAP_REGISTER_CLOSURE` Capability 时，方可调用 `edsos_register_closure(...)` 注册 SDSC。普通节点默认无此权限。单个节点可注册的 SDSC 数量存在上限。
- **禁止信号嵌套与自触发**：
  - SDSC 内部不可调用 `wait` 等待任何信号；
  - 节点不可 `signal` 自身 SDSC 所监听的信号。
- **数据访问范围显式声明**：
  - 注册时必须明确指定 `data_start` 与 `data_length`；
  - `data_length` 不得超过单页内存大小（通常为 4 KiB）。
- **指令来源与长度限制**：
  - `code_start` 必须指向绑定节点自身的指令段；
  - `code_length` 不得超过 256 字节；
  - 指令序列不得包含函数调用，且其执行权限不得超过绑定节点的权限。
- **参数与返回限制**：
  - 唯一输入为信号触发时的附加信息；
  - 无返回机制，执行状态在指令流结束后立即丢弃。

> 注：仅包含有效指令段的 AS 节点方可注册 SDSC。信号附加信息的格式与语义详见 §2.3.2.4.2。

---

## 2.3.4 负载均衡

### 2.3.4.1 负载均衡的策略与触发条件

EDSOS 采用 **Work-Stealing++** 机制实现负载均衡。该机制是对传统工作窃取（Work-Stealing）模型的扩展，其核心目标并非使各 CPU 核心的就绪节点数量绝对均等，而是**最大化结构亲和性、最小化上下文切换开销与跨核通信成本**。Work-Stealing++ 完全去中心化，以 AS 子树为迁移单位，依赖链式消息总线进行核心间协商，并通过代理节点缓存降低协调开销。

调度器持续监控本地负载状态。当满足以下任一条件时，将触发 Work-Stealing++ 流程：

- **子树规模失衡**：某 AS 子树的节点数量超过预设阈值（例如 1024），导致本地调度延迟上升；
- **AS 分散度过高**：同一 AS 的子树分布在三个或更多 CPU 核心上，引发频繁的跨核信号唤醒与 TLB 冷启动；
- **异常负载波动**：通过链式消息总线或处理器间中断（IPI）接收到邻近核心的过载告警（例如就绪队列长度超过高水位线）；
- **性能敏感 AS 争用**：多个性能敏感型 AS（如云游戏主逻辑、实时音视频处理）共享同一核心，导致调度抖动加剧。

EDSOS 不强制追求负载的数值均衡。例如，一个核心运行多个低优先级 AS，而另一核心独占一个高优先级 AS 的状态，可能被视为符合调度目标的配置。

--- 

### 2.3.4.2 去中心化协商机制：基于链式消息总线的请求-响应模型

#### 2.3.4.2.1 主动请求的触发条件

调度器持续监控本地就绪队列长度与 AS 分布状态。满足以下任一条件时，核心将主动发起负载协商请求：

1. **过载状态**：本地就绪队列长度超过高水位阈值（`HIGH_WATERMARK`），此时广播 `TASK_GIVE_REQUEST` 消息，附带以下信息：
  - 可迁移的 AS 子树列表（按结构亲和性排序）；
  - 性能敏感度标签（如“实时”“批处理”）。
  
2. **空闲状态**：本地就绪队列长度低于低水位阈值（`LOW_WATERMARK`），且未收到其他核心的 `TASK_GIVE_REQUEST` 消息，此时广播 `TASK_GET_REQUEST` 消息，附带以下信息：
  - 本核心的空闲容量；
  - 优先接收的 AS 类型（如“计算密集型”“I/O 绑定型”）。

#### 2.3.4.2.2 响应与迁移决策

1. **响应生成**  
   收到 `TASK_GIVE_REQUEST` 或 `TASK_GET_REQUEST` 消息的核心，若具备接收或提供任务的能力，则回复 `STEAL_OFFER` 消息，内容包括：
   - 本核心的当前空闲容量；
   - 本地已调度的 AS 数量；
   - 其他用于迁移决策的辅助信息（如 NUMA 节点归属、当前运行的 AS 类型）。

2. **迁移决策**  
   请求方（Giver）收集所有 `STEAL_OFFER` 后，依据以下策略选择目标核心（Taker）：
   - 优先选择与 Giver 位于同一 NUMA 域的核心；
   - 若迁移子树属于性能敏感型 AS，则选择当前 AS 数量较少且未运行其他关键 AS 的核心；
   - 否则，选择空闲容量最大的核心。

3. **迁移指令下发**  
   决策完成后，Giver 通过链式消息总线向选定的 Taker 发送 `MIGRATE_SUBTREE(subtree_root_gva, target_core)` 指令，启动子树迁移流程。

整个协商过程通过链式消息总线异步完成，不阻塞本地调度器的正常调度操作。

---

### 2.3.4.3 子树级迁移

EDSOS 的负载均衡机制以 **完整的 AS 子树** 为基本迁移单位。迁移操作必须包含以某一节点为根的全部后代节点，禁止仅迁移部分子孙节点（即“断枝”迁移）。

采用子树作为迁移单位主要基于以下两点技术约束：

1. **TLB 亲和性保障**：AS 子树内的所有节点共享相同的祖先链。迁移完整子树后，目标核心可一次性预热整条祖先链的 TLB 条目，确保作用域内内存访问的高效性与安全性。
2. **信号局部性维护**：若子树内多个节点等待同一 EDSOS Semaphore，拆分迁移将导致跨核心唤醒，增加链式消息总线通信开销并降低同步效率。

因此，调度器在执行迁移前会验证子树结构的完整性，确保迁移操作不会破坏 AS 的拓扑语义。

子树迁移由源核心（Giver）与目标核心（Taker）协同完成，具体步骤如下：

1. **暂停子树执行**：Giver 调度器对整棵待迁移子树执行 `yield` 操作，将其所有节点状态置为 `ready` 并保存上下文。
2. **传输元数据**：通过链式消息总线，Giver 向 Taker 发送子树根节点的线性虚拟地址（LVA）及子树拓扑信息。
3. **更新归属信息**：子树中所有节点的 `subtree_home_core` 字段被更新为目标核心 ID。
4. **接入目标就绪链表**：Taker 调度器将子树根节点加入其本地就绪链表，后续调度将按常规流程激活子树内节点。

迁移过程不涉及节点内存内容的复制，仅转移调度上下文与核心归属，实现 **数据零拷贝** 。节点的虚拟地址空间保持不变，页表映射由硅中介层在跨核心调度时按需重建。

--- 

### 2.3.4.4 代理节点机制：减少跨 Core 通信

为减少同一 AS 分散在多个 CPU 核心时的协调开销，EDSOS 引入 **代理节点缓存机制**。该机制通过在本地缓存远程子树或祖先链的关键结构信息，避免频繁的全局查询与跨核同步，适用于同一处理器内不同核心之间以及跨物理节点（PM）的场景。

#### 2.3.4.4.1 代理根节点（Proxy Root Node）

当某核心上运行的 AS 子树的上游祖先节点位于其他核心时，调度器在该核心上创建一个**代理根节点**，用于缓存从本地子树根节点向上直至 AS 全局根节点的祖先链信息。

代理根节点的主要用途包括：
- 支持 TLB 预热过程中对完整祖先链的遍历；
- 为 Capability 验证提供必要的上下文；
- 接收来自上游核心的结构变更消息（如 `lift` 或 `merge` 操作影响到祖先链）。

代理根节点不包含实际执行逻辑，仅作为结构元数据的只读缓存。

#### 2.3.4.4.2 代理子节点（Proxy Child Node）

当某核心上的 AS 节点将一个子树迁移至其他核心后，调度器在原核心上创建一个**代理子节点**，用于缓存该子树在目标核心上的结构信息。

代理子节点的主要用途包括：
- 为跨核信号信号（`signal`）提供路由信息，确保信号能正确投递至目标子树；
- 接收来自下游核心的结构变更通知（如子树内部发生 `detach` 或 `finish` 操作）。

与代理根节点类似，代理子节点亦为只读缓存，不参与执行或调度。

---

### 2.3.4.5 AS 感知的均衡策略

EDSOS 将 AS 分为两类，采用差异化调度策略：

| AS 类型 | 示例 | 调度策略 |
|--------|------|----------|
| **性能敏感型** | 云游戏主逻辑、实时控制 | 尽量独占 Core，避免与其他 AS 共享 |
| **性能不敏感型** | Capability 鉴权、注册表服务 | 多个可共用同一 Core，主动承担上下文切换开销 |

调度器通过节点中的 `perf_sensitivity` 标签识别类型，并在 Work-Stealing++ 决策中加权。

---

*End of Execution Subsystem Document.*