<!--
SPDX-FileCopyrightText: © 2025-2026 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 1.2 Execution Model

---

> v0.1.3-drafting

---

- [1.2 Execution Model](#12-execution-model)
  - [1.2.1 AS 实例作为基本执行体](#121-as-实例作为基本执行体)
    - [1.2.1.1 进程即 AS：从抽象到实例](#1211-进程即-as从抽象到实例)
    - [1.2.1.2 节点：执行与内存的统一体](#1212-节点执行与内存的统一体)
    - [1.2.1.3 节点状态机与操作](#1213-节点状态机与操作)
    - [1.2.1.4 与传统进程模型的对应](#1214-与传统进程模型的对应)
  - [1.2.2 Meta-AS：系统的全局结构化视图](#122-meta-as系统的全局结构化视图)
    - [1.2.2.1 系统服务的 AS 表达](#1221-系统服务的-as-表达)
    - [1.2.2.2 硅中介层：底层执行支持](#1222-硅中介层底层执行支持)
  - [1.2.3 Execution Model Implementation](#123-execution-model-implementation)
    - [1.2.3.1 Arbor Strux (AS) Representation](#1231-arbor-strux-as-representation)
      - [1.2.3.1.1 AS Construction: Role of the EDSOS Loader](#12311-as-construction-role-of-the-edsos-loader)
      - [1.2.3.1.2 AS Lifecycle Management](#12312-as-lifecycle-management)
      - [1.2.3.1.3 AS Instance Identification and Naming](#12313-as-instance-identification-and-naming)
    - [1.2.3.2 Cross-AS Communication via CARN](#1232-cross-as-communication-via-carn)
      - [1.2.3.2.1 CARN Definition](#12321-carn-definition)
      - [1.2.3.2.2 CARN Operational Workflow](#12322-carn-operational-workflow)


---

## 1.2.1 AS 实例作为基本执行体

EDSOS 严格遵循 AS 理论，工程化了 **Arbor Strux（AS）结构**作为传统“进程”概念的对应。该结构完整表达了运行时的控制流、数据流、作用域、生命周期及局部性等执行语义，是 EDSOS 的基本执行原语。

### 1.2.1.1 进程即 AS：从抽象到实例

每个 EDSOS AS 实例在创建时，由 EDSOS Loader 构造一棵初始 AS。该 AS 的根节点具有特殊语义：它对应于传统操作系统中进程控制块（PCB），并扩展了 EDSOS 特有的元信息，包括：

- 全局唯一的AS实例标识符（ASID）；
- Capability 政策（按策略匹配而非静态的可访问列表）；
- 调度策略；
- 其他系统级属性。

除根节点外，AS 中的所有其他节点均为普通 AS 节点。这些节点无全局标识符，仅通过虚拟地址与父子指针在树中定位和联结。该设计消除了传统模型中“线程 ID”“栈指针”“堆段”等离散概念，将其统一为 AS 节点的结构属性。尽管其组织形式在拓扑上与 Linux 的 VMA 结构有相同之处，但在语义内容、操作接口及执行模型上存在本质差异。

### 1.2.1.2 节点：执行与内存的统一体

节点是 EDSOS 中最小的可调度、可执行的原子单元。每个节点在虚拟地址空间中占据一段连续的虚拟页（Virtual Pages, VPs），并包含三个逻辑段：

- **元数据段**：存储节点类型、大小、祖先路径哈希等信息；
- **数据段**：用于存放变量字段。
- **指令段**：包含一段符合 EDSOS Standard ABI 的代码流；

节点基本结构由 AS 形式化模型规定，并由 Arxil 语言精确描述。其中，节点可以仅包含数据段（无指令段），称为退化节点，专门用于数据缓存与共享；包含有效指令段的普通节点可被调度执行，行为类似于协程。

### 1.2.1.3 节点状态机与操作

EDSOS 中所有节点操作的语义遵循 AS 模型的定义。每个 AS 节点的状态由一个五态状态机描述：

| 状态       | 含义                    |
|----------|-------------------------|
| ready    | 就绪，等待调度          |
| running  | 正在执行                |
| blocked  | 阻塞，等待信号          |
| zombie   | 临终，等待父节点回收    |
| error    | 发生安全异常，已终止    |

节点的状态转换及结构变更通过以下十种（效果上原子的）操作实现，均由调度器执行：

| 操作   | 含义                                             |
|--------|--------------------------------------------------|
| push   | 在当前节点下创建一个新叶子节点                   |
| active | 调度器将 ready 节点激活为 running 状态           |
| wait   | running 节点阻塞，等待指定 EDSOS Semaphore       |
| pivot  | 将当前节点挂载至更高层祖先下，改变其作用域       |
| merge  | 将当前节点与其子节点合并，扩展虚拟地址空间       |
| detach | 将当前节点的一部分数据分裂为新子节点             |
| yield  | 暂停 running 节点，保存上下文并返回 ready 状态   |
| finish | 节点执行结束，进入 zombie 状态                   |
| pop    | 父节点回收已处于 zombie 状态的子节点             |
| warn   | 触发安全异常，将节点及其子树置为 error 状态      |

这些操作本身内置于 Arxil 的语言关键字。

### 1.2.1.4 与传统进程模型的对应

| 传统概念         | EDSOS 对应           | 说明                       |
|----------------|--------------------|------------------------------|
| 进程地址空间     | 整棵 AS              | 作用域由树结构隐式限定       |
| 线程             | 可并行调度的 AS 节点 | 支持父子节点并发执行         |
| 栈帧             | AS 节点的数据段      | 大小受 TLB 容量约束          |
| 堆内存           | 退化节点的数据段     | 生命周期由引用计数管理       |
| 进程控制块 (PCB) | AS 根节点            | 包含 Capability 与调度元数据 |

## 1.2.2 Meta-AS：系统的全局结构化视图

EDSOS 采用一种全结构化的系统模型。整个运行时系统——包括用户应用、系统服务、设备驱动、安全策略模块等——共同构成 **Meta-AS（Meta-Arbor Strux）** 结构。

Meta-AS 是当前存在的所有 AS 实例，按照一定的结构联结起来构成的逻辑结构。一个 EDSOS 系统实例就是一个符合 Meta-AS 结构的系统实例，各个 AS 实例之间通过显式的结构操作进行协作，保证系统整体的良构性。

### 1.2.2.1 系统服务的 AS 表达

EDSOS 中系统服务（如文件、网络）同样以 AS 实例形式存在，通过结构共享与信号同步协作，并在结构上保持对等：

- **用户 AS**：例如 `/user_a/chrome_instance_01`，表示一个浏览器实例；
- **系统服务 AS**：例如 `/net/sockets`、`/fs/ext4_main`、`/auth/cap_validator`，分别提供网络通信、文件系统和 Capability 验证服务；
- **驱动 AS**：例如 `/drivers/net/e1000`、`/drivers/storage/nvme_ctrl`，直接管理硬件设备。

这些 AS 遵循相同的结构公理：
- 由 AS 节点构成；
- 可被调度器调度；
- 通过 CARN 和 EDSOS Semaphore 与其他 AS 通信。

它们之间的差异仅体现在 Capability 授权范围与硬件访问权限上，而非执行模型本身。每个 AS 实例可包含一个或（分布运行在多个 CPU 核心时）多个 **SPN（System Proxy Node）** 作为与其他 AS 实例通信的代理，详见 [§2.5 系统调用模型](../2-Architecture/2.5-Syscall-Model.md)。该设计在保留微内核安全边界的同时，通过结构化共享避免了传统微内核中因频繁 IPC 导致的性能瓶颈。

### 1.2.2.2 硅中介层：底层执行支持

传统操作系统中由内核提供的基础功能（如内存映射、TLB 管理、上下文切换、中断处理）在 EDSOS 中由 **硅中介层（Silicon Interposer）** 实现。硅中介层具有以下特征：

- 直接运行于裸金属之上；
- 提供调度器、中断响应、内存分配与映射等底层原语；
- 所有 AS 通过加载期 ABI 内联指令直接调用其服务；
- AS 间的通信通过 CARN、链式消息总线和 EDSOS Semaphore 实现。

硅中介层不表现为任何 AS 节点，而是实现 AS 模型的基本结构性质，提供所有节点所需的 AS 模型逻辑。**本文档所述的调度器逻辑、内存管理原语及其他底层机制均属于硅中介层的范畴。**

该设计大幅减小了攻击面：系统调用要么由调度器在本地处理（通过隐式的特权切换），要么通过异步委托交由服务 AS 执行（不在当前 AS 的执行上下文中完成）。

硅中介层自身可以类比于并称为实际的*内核*。这具备显著的*微内核*风格和*ring -1虚拟机管理器*风格。

---

## 1.2.3 Execution Model Implementation

### 1.2.3.1 Arbor Strux (AS) Representation

#### 1.2.3.1.1 AS Construction: Role of the EDSOS Loader

The initial topology of an AS instance is constructed by the **EDSOS Loader** during the loading phase. The process proceeds as follows:

1. **ELF and Manifest Parsing**  
   The loader extracts the entry function, library dependencies, and declared capabilities from the binary manifest. It scans for system call instructions and inlines valid syscall stubs into native x86-64 sequences. Invalid syscalls are either rejected (default policy) or replaced with compatibility-layer shims in degraded mode. Library dependencies conform to the Arxil `.arxlib` specification.

2. **Virtual Address and Metadata Allocation**  
   The loader requests the Memory Subsystem to allocate contiguous **Local Virtual Addresses (LVAs)** for each node. A metadata segment (`.edsos_node_meta`) is generated per node, containing fields such as `vbase`, `size`, and `ancestor_path_hint`.

3. **Initial Tree Topology Assembly**  
   A root node is created and injected with its capability set and a view of accessible system resources. The main entry function is attached as a direct child of the root. Static constructs are organized into subtrees according to lexical scope relationships.

The output of the loader is a fully formed AS instance, rooted and ready for immediate scheduling.

#### 1.2.3.1.2 AS Lifecycle Management

In EDSOS, “process creation” is equivalent to constructing a new AS instance and integrating its root node into the logical structure of the Meta-AS.

**Creation proceeds as follows**:
1. A parent AS instance invokes `edsos_spawn()`;
2. The scheduler triggers the **EDSOS Loader**, which parses the target ELF binary and its associated Capability manifest;
3. The Loader constructs the initial AS instance topology;
4. The root node of the new AS instance is attached as a child to a designated management node (analogous to Unix process groups) and registered in the global namespace;
5. All nodes of the new AS instance are marked as `ready` and become eligible for scheduling.

**Destruction proceeds as follows**:
1. The user calls `exit()` or an unrecoverable exception occurs;
2. The scheduler recursively reclaims the entire AS instance;
3. When the reference count reaches zero, any associated **CARNs** (Cross-AS Referring Nodes) are automatically deallocated, ensuring no memory leaks.

The entire lifecycle is implicitly managed through AS structural references and reference counting—**no global process table is required**.

#### 1.2.3.1.3 AS Instance Identification and Naming

Each AS instance is assigned a globally unique **64-bit ASID** (Arbor Strux Identifier), stored in its root node. ASIDs are allocated by a dedicated **System Resource Management Service** and recorded in a distributed registry. Human-readable aliases may be bound to ASIDs.

Capability strategy and compatibility-mode metadata are embedded into the root node during loading and remain **immutable for the lifetime of the AS**.

---

### 1.2.3.2 Cross-AS Communication via CARN

EDSOS replaces traditional IPC with a structured shared-memory mechanism based on **CARNs (Cross-AS Referring Nodes)**. Crucially, CARNs provide only a **structured reference channel**; all concurrency control must be explicitly orchestrated using **EDSOS Semaphores** or other synchronization primitives.

#### 1.2.3.2.1 CARN Definition

A CARN is a degenerate AS node with special semantics, enabling explicit data sharing across multiple AS instances. Its key properties are:

- In each referencing AS instance, the CARN appears as an ordinary node and adheres to that AS’s structural constraints;
- No AS can traverse a CARN to access the direct ancestors of another AS’s CARN, preserving **lexical scoping and isolation**;
- CARNs carry no built-in concurrency semantics. Race conditions must be prevented via explicit synchronization such as EDSOS Semaphores.

#### 1.2.3.2.2 CARN Operational Workflow

- **Creation**: Node A executes `push(CARN_X)`, making CARN_X its child;
- **Registration**: CARN_X is published to a global naming table (implemented as a distributed hash table);
- **Scope Elevation (optional)**: A executes `pivot(CARN_X)` to promote it into an ancestor, enabling self-access;
- **Cross-AS Binding**:
  - Node B performs `lookup("CARN_X")` to obtain its virtual address;
  - B executes `push(CARN_X_VA, 'as_ctrn')` followed by `pivot(CARN_X)`, integrating the CARN into its own ancestry;
- **Disconnection**: Any participant may call `pop` on the CARN, decrementing its reference count. When the count reaches zero, the CARN is automatically reclaimed.

This mechanism guarantees structural integrity and memory safety in shared data access.

---

*End of Document.*