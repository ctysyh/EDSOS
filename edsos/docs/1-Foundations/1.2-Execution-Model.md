<!--
SPDX-FileCopyrightText: © 2025 Bib Guake
SPDX-License-Identifier: LGPL-3.0-or-later
-->

# 1.2 Execution Model

---

v0.1.3-drafting

---

- [1.2 Execution Model](#12-execution-model)
  - [1.2.1 AS 实例作为基本执行体](#121-as-实例作为基本执行体)
    - [1.2.1.1 进程即 AS：从抽象到实例](#1211-进程即-as从抽象到实例)
    - [1.2.1.2 节点：执行与内存的统一体](#1212-节点执行与内存的统一体)
    - [1.2.1.3 节点状态机与操作](#1213-节点状态机与操作)
    - [1.2.1.4 与传统进程模型的映射](#1214-与传统进程模型的映射)
  - [1.2.2 Meta-AS：系统的全局结构化视图](#122-meta-as系统的全局结构化视图)
    - [1.2.2.1 系统服务的 AS 表达](#1221-系统服务的-as-表达)
    - [1.2.2.2 硅中介层：底层执行支持](#1222-硅中介层底层执行支持)
  - [**1.2.3 节点操作与生命周期**](#123-节点操作与生命周期)
    - [**1.2.3.1 原子操作语义**](#1231-原子操作语义)
      - [**1.2.3.1.1 `push`：原子创建，无中间态**](#12311-push原子创建无中间态)
      - [**1.2.3.1.2 `active`：调度器驱动的上下文激活**](#12312-active调度器驱动的上下文激活)
      - [**1.2.3.1.3 `wait`：阻塞与信号驱动唤醒**](#12313-wait阻塞与信号驱动唤醒)
      - [**1.2.3.1.4 `pivot`：结构变更，需 yield**](#12314-pivot结构变更需-yield)
      - [**1.2.3.1.5 `merge`：扩容操作，需 yield**](#12315-merge扩容操作需-yield)
      - [**1.2.3.1.6 `detach`：分裂操作，需 yield**](#12316-detach分裂操作需-yield)
      - [**1.2.3.1.7 `yield`：中断驱动的上下文冻结**](#12317-yield中断驱动的上下文冻结)
      - [**1.2.3.1.8 `finish`：正常退出**](#12318-finish正常退出)
      - [**1.2.3.1.9 `pop`：父节点回收子节点**](#12319-pop父节点回收子节点)
      - [**1.2.3.1.10 `warn`：安全异常**](#123110-warn安全异常)
    - [1.2.3.2 安全异常处理：`warn` 与子树终止](#1232-安全异常处理warn-与子树终止)


---

## 1.2.1 AS 实例作为基本执行体

EDSOS 严格遵循 AS 理论，工程化了 **Arbor Strux（AS）结构**作为传统“进程”概念的对应。该结构完整表达了运行时的控制流、数据流、作用域、生命周期及局部性等执行语义，是 EDSOS 的基本执行原语。

### 1.2.1.1 进程即 AS：从抽象到实例

每个 EDSOS AS 实例在创建时，由 EDSOS Loader 构造一棵初始 AS。该 AS 的根节点具有特殊语义：它承载了传统操作系统中进程控制块（PCB）的全部元信息，并扩展了 EDSOS 特有的元数据，包括：

- 全局唯一的进程标识符（PID）；
- Capability 政策；
- 调度策略；
- 其他系统级属性。

除根节点外，AS 中的所有其他节点均为普通 AS 节点。这些节点无全局标识符，仅通过父子指针在树中定位。该设计消除了传统模型中“线程 ID”“栈指针”“堆段”等离散概念，将其统一为 AS 节点的结构属性。尽管其组织形式在拓扑上类似于 Linux 的 VMA 结构，但在语义内容、操作接口及执行模型上存在本质差异。

### 1.2.1.2 节点：执行与内存的统一体

节点是 EDSOS 中最小的可调度、可执行且可共享的原子单元。每个节点在虚拟地址空间中占据一段连续的虚拟页（Virtual Pages, VPs），并包含三个逻辑段：

- **元数据段**：存储节点类型、大小、祖先路径哈希等信息；
- **指令段**：包含一段符合 EDSOS Standard ABI 的代码流；
- **数据段**：用于存放变量字段。

非根的普通节点的运行时语义由其内容与上下文共同决定：

- 若包含有效指令段，则可被调度执行，行为类似于协程或函数调用帧；
- 若仅包含数据段（无指令段），则为退化节点，专门用于数据缓存与共享。

### 1.2.1.3 节点状态机与操作

EDSOS 中所有节点操作的语义遵循 AS 模型的定义。每个 AS 节点的状态由一个五态状态机描述：

| 状态       | 含义                    |
|----------|-------------------------|
| ready    | 就绪，等待调度          |
| running  | 正在执行                |
| blocked    | 阻塞，等待信号          |
| zombie   | 临终，等待父节点回收    |
| error    | 发生安全异常，已终止    |

节点的状态转换及结构变更通过以下十种（效果上原子的）操作实现，均由调度器执行：

| 操作   | 含义                                             |
|--------|--------------------------------------------------|
| push   | 在当前节点下创建一个新叶子节点                   |
| active | 调度器将 ready 节点激活为 running 状态           |
| wait   | running 节点阻塞，等待指定 EDSOS Semaphore       |
| pivot   | 将当前节点挂载至更高层祖先下，改变其作用域       |
| merge  | 将当前节点与其子节点合并，扩展虚拟地址空间       |
| detach | 将当前节点的一部分数据分裂为新子节点             |
| yield  | 暂停 running 节点，保存上下文并返回 ready 状态   |
| finish | 节点执行结束，进入 zombie 状态                   |
| pop    | 父节点回收已处于 zombie 状态的子节点             |
| warn   | 触发安全异常，将节点及其子树置为 error 状态      |

### 1.2.1.4 与传统进程模型的映射

| 传统概念         | EDSOS 对应           | 说明                       |
|----------------|--------------------|------------------------------|
| 进程地址空间     | 整棵 AS              | 作用域由树结构隐式限定       |
| 线程             | 可并行调度的 AS 节点 | 支持父子节点并发执行         |
| 栈帧             | AS 节点的数据段      | 大小受 TLB 容量约束          |
| 堆内存           | 退化节点的数据段     | 生命周期由引用计数管理       |
| 进程控制块 (PCB) | AS 根节点            | 包含 Capability 与调度元数据 |

## 1.2.2 Meta-AS：系统的全局结构化视图

EDSOS 采用一种全结构化的系统模型。整个运行时系统——包括用户应用、系统服务、设备驱动、安全策略模块等——共同构成 **Meta-AS（Meta-Arbor Strux）** 结构。

Meta-AS 是当前存在的所有 AS 实例，按照一定的结构联结起来构成的逻辑结构。一个 EDSOS 系统实例就是一个符合 Meta-AS 结构的系统实例，各个 AS 实例之间通过显式的结构操作进行协作，保证系统整体的良构性。

### 1.2.2.1 系统服务的 AS 表达

EDSOS 中没有传统上“系统调用并进入内核态”的直接语义。系统服务（如文件、网络）同样以 AS 实例形式存在，通过结构共享与信号同步协作，并在结构上保持对等：

- **用户 AS**：例如 `/user_a/chrome_instance_01`，表示一个浏览器实例；
- **系统服务 AS**：例如 `/net/sockets`、`/fs/ext4_main`、`/auth/cap_validator`，分别提供网络通信、文件系统和 Capability 验证服务；
- **驱动 AS**：例如 `/drivers/net/e1000`、`/drivers/storage/nvme_ctrl`，直接管理硬件设备。

这些 AS 遵循相同的结构公理：
- 由 AS 节点构成；
- 可被调度器调度；
- 通过 CARN 和 EDSOS Semaphore 与其他 AS 通信。

它们之间的差异仅体现在 Capability 授权范围与硬件访问权限上，而非执行模型本身。每个 AS 实例可包含一个或（分布运行在多个 CPU 核心时）多个 **SPN（System Proxy Node）** 作为与其他 AS 实例通信的代理，详见 §1.3.5 系统调用模型。该设计在保留微内核安全边界的同时，通过结构化共享避免了传统微内核中因频繁 IPC 导致的性能瓶颈。

### 1.2.2.2 硅中介层：底层执行支持

传统操作系统中由内核提供的基础功能（如内存映射、TLB 管理、上下文切换、中断处理）在 EDSOS 中由 **硅中介层（Silicon Interposer）** 实现。硅中介层具有以下特征：

- 直接运行于裸金属之上；
- 提供调度器、中断响应、内存分配与映射等底层原语；
- 所有 AS 通过加载期 ABI 内联指令直接调用其服务；
- AS 间的通信通过 CARN、链式消息总线和 EDSOS Semaphore 实现。

硅中介层不表现为任何 AS 节点，而是实现 AS 模型的基本结构性质，提供所有节点所需的 AS 模型逻辑。**本文档所述的调度器逻辑、内存管理原语及其他底层机制均属于硅中介层的范畴。**

该设计消除了“陷入内核”的概念：系统调用要么由调度器在本地处理（通过隐式的特权切换），要么通过异步委托交由服务 AS 执行（不在当前 AS 的执行上下文中完成）。

## **1.2.3 节点操作与生命周期**

### **1.2.3.1 原子操作语义**

#### **1.2.3.1.1 `push`：原子创建，无中间态**

- **语义**：创建新叶子节点，挂载为当前节点的子节点。
- **触发者**：当前 running 节点（如函数调用、线程 spawn）。
- **起始和目标状态**：空内容 → ready。
- **原子性保证**：
  - 内存子系统必须 **一次性分配所有 VPs**；
  - 若 VP 不足 → 返回错误，不创建部分节点；
  - 跨机 push：目标 PM 完成 VP 分配 + 祖先链验证后，才返回成功。
- **并行性**：多个核心可并发 push 不同父节点的子节点，无冲突。
- **无需中间态**。

#### **1.2.3.1.2 `active`：调度器驱动的上下文激活**

- **语义**：将 ready 节点调度到 CPU 核心执行。
- **触发者**：调度器。
- **起始和目标状态**：ready → running。
- **关键点**：
  - **不限于叶子节点**：父子可并行（如协程 + 主线程）；
  - **调度器责任**：
    1. 选择 ready 节点；
    2. 重建其祖先链（通过父指针遍历）；
    3. **增量 TLB 预热**（L1: 自身；L2: 祖先）；
    4. 加载寄存器上下文；
    5. 切换到 running。
- **失败处理**：
  - TLB 预热失败（罕见）→ 标记 error，尝试下一节点；
  - 无 ready 节点 → 进入 idle。
- **并行模型**：同片/跨片核心调度逻辑一致，仅 TLB 预热延迟不同。

#### **1.2.3.1.3 `wait`：阻塞与信号驱动唤醒**

- **语义**：节点主动放弃 CPU，等待某信号（I/O 完成、锁释放等）。
- **起始和目标状态**：running → blocked。
- **实现机制**：
  - 节点调用 `edsos_wait(event_id)`；
  - EDSOS 将节点加入 **event_id 的等待队列**；
  - 状态转为 blocked；
  - 当信号发生，**信号管理器**遍历队列，将节点状态转为 ready。
- **关键要求**：
  - **唤醒必须精准**：避免虚假唤醒（spurious wakeup）；
  - **无竞态**：wait 与 event_signal 需原子协调（通过内存子系统信号总线）。
- **并行性**：多个节点可 wait 同一信号，无冲突。

#### **1.2.3.1.4 `pivot`：结构变更，需 yield**

- **语义**：将节点挂载到更高祖先下，改变其作用域。
- **起始和目标状态**：结构变更。
- **无需中间状态**，但需 **yield 所有子孙节点**。
- **详细流程**：
  1. 节点发起 pivot(target_ancestor_gva)；
  2. EDSOS 验证 target_ancestor 在 AS 树中（通过 LVA 遍历）；
  3. **暂停所有子孙节点**（递推调用 `yield`）；
  4. 原子更新父指针；
  5. 子孙节点状态仍为 ready，但下次 active 时将使用新祖链。
- **为什么无需 pivot_pending**？
  - 因为 **作用域变更对子孙不可见，直到它们被重新调度**；
  - TLB 是 per-core 的，旧核心的 TLB 仍有效，直到被刷新；
  - **安全由调度器保证**：子孙下次运行时，TLB 预热基于新父链。
- **跨机 pivot**：跨机传输新挂载点，目标 PM 执行相同 yield + 更新；通过代理根节点（缓存本机子树的根节点之上的信息，接收其他 PM 发来的作用到本机子树根节点的直系祖节点链的结构变更消息）和代理子节点（缓存本机父树的从一个节点开始的子树在其他 PM 的信息，接收其他 PM 发来的从子树向上作用到这个节点的结构变更消息）来在每个 PM 中缓存信息，减少频繁跨机访问开销。

#### **1.2.3.1.5 `merge`：扩容操作，需 yield**

- **语义**：将自身与一个“扩展子节点”合并，扩大虚拟地址范围。
- **起始和目标状态**：结构变更。
- **流程**：
  1. 先 `push` 一个扩展子节点（仅数据段）；
  2. 调用 `merge(child_gva)`；
  3. **yield 自身**（若 running）；
  4. 内存子系统 **虚拟重映射**：将 child 的 VPs 合并到父的地址空间；
  5. 更新 `vbase/size`；
  6. 子节点标记为 zombie；
  7. 自身状态仍为 ready（若原为 ready）或 running（下次调度恢复）。
- **关键**：merge 期间，**自身不能执行**，故需 yield。
- **无需 merge_pending**：因操作在 yield 保护下原子完成。

---

#### **1.2.3.1.6 `detach`：分裂操作，需 yield**

- **语义**：将部分数据分裂为新子节点，用于回收或 pivot。
- **起始和目标状态**：结构变更。
- **流程**：
  1. **yield 自身**；
  2. 内存子系统分配新 VPs；
  3. 迁移数据；
  4. 创建新子节点（状态 ready）；
  5. 更新自身 `vbase/size`；
  6. 恢复状态。
- **典型场景**：冷数据回收 → detach → pivot 到全局缓存池。

---

#### **1.2.3.1.7 `yield`：中断驱动的上下文冻结**

- **语义**：将 running 节点暂停，保存上下文，回到 ready。
- **起始和目标状态**：running → ready。
- **触发场景**：
  - 定时器中断（时间片到期）；
  - TLB 一致性中断（跨核 TLB 刷新）；
  - 调度器主动抢占；
  - pivot/merge/detach 需要暂停。
- **操作**：
  - 保存寄存器；
  - 状态 → ready；
  - **不清空 TLB**（下次 active 可复用，除非祖链变更）。

---

#### **1.2.3.1.8 `finish`：正常退出**

- **语义**：节点执行完毕，进入 zombie。
- **触发**：`return` 或 `edsos_exit()`。
- **起始和目标状态**：running → zombie。
- **行为**：
  - 若有子节点，**递归 finish**（AS 子树语义）；
  - 父节点可 later `pop`。

---

#### **1.2.3.1.9 `pop`：父节点回收子节点**

- **语义**：父节点显式回收已 zombie 的子节点。
- **起始和目标状态**：zombie → 空内容。
- **原子性**：检查子节点状态 == zombie → 释放内存 → 删除父指针。
- **跨机 pop**：通过代理子节点向对应的远程 PM 中的代理根节点发送 `pop` 消息。

---

#### **1.2.3.1.10 `warn`：安全异常**

- **语义**：强制进入 error 状态，终止子树。
- **起始和目标状态**：any → error。
- **触发**：
  - Page Fault 验证失败（访问非法地址）；
  - 元数据 magic 错误；
  - 签名无效；
  - 其他异常和错误。
- **行为**：
  - 状态 → error；
  - **递归 error 所有子孙**；
  - 上报安全日志；
  - 父节点可选择 ignore 或 terminate。

---

### 1.2.3.2 安全异常处理：`warn` 与子树终止
<TODO>