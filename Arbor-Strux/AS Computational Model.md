<!--
SPDX-FileCopyrightText: © 2025 Bib Guake
SPDX-License-Identifier: CC-BY-4.0
-->

# AS Computational Model

> AS 计算模型概论

## 1. 核心理念：计算即结构演化

AS（Arbor Strux）计算模型的根本主张是：**程序不是一段在固定地址空间中跳转的指令序列，而是一棵在运行时动态生长、收缩、协作的结构树**。这一理念带来三大范式转变：

| 传统模型 | AS 模型 |
|----------|--------|
| 状态 = 内存地址 + 寄存器 | 状态 = 节点字段（结构化命名空间） |
| 控制流 = 程序计数器（PC）跳转 | 控制流 = 树的局部执行 + 全局结构变更 |
| 并发 = 线程/进程切换 | 并发 = 节点并行（调度器管理子树） |

Arxil（Arbor Strux Intermediate Language）作为这一理念的文本表达，并不描述“做什么”，而是描述“如何组织自己以安全、高效地做”。计算的本质不再是线性控制流，而是**结构的演化过程**。

---

## 2. 节点（Node）作为统一计算单元

在 AS 模型中，**节点是基本的结构与执行原子**，兼具栈帧与线程的双重身份：

### 2.1 节点的双重身份
- **轻量级**：可代表单个函数调用的栈帧（短生命周期、无独立调度）；
- **重量级**：可代表独立任务或线程（长生命周期、可真并行执行）。

这种统一性源于节点的三个核心属性：
- **结构嵌套**：子节点天然继承父节点的能力（capability）与数据可见性上下文；
- **封闭命名空间**：节点内字段无需前缀，编译器自动解析作用域链；
- **显式生命周期**：通过 `push` / `pop` / `finish` 显式控制存在性，替代隐式栈分配或垃圾回收。

---

### 2.2 节点的内部结构
每个节点由三大部分组成：
- **`meta_data`**：包含运行时元信息（如状态、能力标识、引用计数等）；
- **`data`**：结构化字段区，分为 `ance`（祖先引用）、`publ`（公开字段）、`priv`（私有字段）；
- **`code`**：指令与函数定义区，包含 `instruct`（主指令流）及若干命名指令块（`fn`）。

节点的内存布局在编译期完全确定，字段不是“变量”，而是**结构中的命名槽位**。

---

## 3. 节点操作语义与执行模型

AS 模型通过一组原子操作实现结构演化与控制流调度：

| 操作 | 语义 | 开销 | 并行性 |
|------|------|------|--------|
| `push N (...)` | 在当前节点下创建子节点 `N` | 中（需调度器注册） | 子节点可真并行 |
| `pop N` | 销毁子节点及其子树（refcount=0 时实际回收） | 低 | — |
| `exe (...) fn_name` | 跳转至同节点内的命名指令块 | 极低（≈ jmp） | 串行（同节点内） |
| `finish this` | 标记当前节点为 `zombie`，等待被 `pop` | 无 | — |
| `pivot data_source (...)` | 将子节点字段绑定到自身 `ance` 字段，实现零拷贝共享 | 低 | — |

---

### 关键执行原则：
- **节点内串行，节点间并行**：同一节点内的指令严格顺序执行；不同节点可由调度器并发调度。
- **调度开销仅发生在节点边界**：`exe` 跳转无上下文切换，`push`/`pop` 是唯一引入调度交互的操作。

---

## 4. 结构化共享与安全协作

AS 模型通过 **显式结构关系** 实现安全、高效的跨节点数据共享，彻底超越传统共享机制（如全局变量、`shared_ptr`、mmap）。

### 4.1 `ance` 字段与绑定机制

- `ance` 字段不持有实际存储，而是对祖先（或潜在祖先）节点中某字段的**引用承诺**；
- 绑定分两阶段：
  1. **预绑定**（`push` 时）：父节点将其字段（即使是未履行的 `ance`）绑定给子节点；
  2. **履行承诺**（`pivot` 时）：将真实数据源（如 CTRN 的 `publ` 字段）注入绑定链上游。

---

### 4.2 零拷贝共享示例

```tsl
push buffer (example_ctrn);
pivot buffer ((a => my_ance_field));
// 此后所有绑定到 my_ance_field 的子孙节点，
// 均直接访问 buffer.a，无数据复制。
```

---

## 5. 与传统系统的兼容策略

AS 不追求取代现有生态，而是提供**渐进式结构化路径**，支持与传统二进制共存。

### 5.1 三层兼容模型

| 层级 | 方法 | 适用场景 |
|------|------|--------|
| 沙箱加载 | 将 ELF/WASM 进程加载为大型 AS 节点 | Legacy 应用无缝运行 |
| IR 转换 | LLVM/WASM → Arxil IR | 源码可用，希望获得 AS 性能和安全性 |
| 混合执行 | AS 节点 + 传统进程共存 | 系统逐步迁移 |

---

### 5.2 传统概念到 AS 的映射

| 传统概念 | AS 映射 |
|----------|--------|
| 函数入口 | 节点 或 同节点 `fn` 块 |
| `call` / `ret` | `push` / `pop`（跨节点） 或 `exe`（同节点） |
| 栈帧 | 节点 `data` 段 |
| 全局变量 | 在根节点声明并通过 `ance` 逐层传导 |
| `pthread_create` | `push` 新节点，或代理根节点动态生长 |

目标：让 legacy 代码“穿上 AS 外衣”，逐步演进为原生结构化程序。

---

## 6. 前沿思考：AS 对现代编程范式的重构

### 6.1 对比 Rust：从“所有权规则”到“结构化内存本体”

Rust 的所有权系统是对传统栈/堆模型的修补，而 AS **重新定义了内存的“长相”**：
- 无栈帧概念：状态驻留在节点实例中；
- 无栈溢出风险：递归 = 新节点，非栈增长；
- 缓存友好：相关字段地址相邻；
- 安全内建：字段访问受结构作用域保护。

---

### 6.2 事件驱动 vs 回调地狱：EDSOS Semaphore 的隔离设计

传统回调在触发方栈上执行，易导致逻辑耦合与重入攻击。  
AS 通过 **EDSOS Semaphore** 实现“逻辑关联，物理隔离”：
```tsl
// 触发方
signal io_complete all;

// 处理方
wait io_complete;
exe (() ()) handle_result;
```
- 双方属于不同节点 → 不同 capability 域、不同 data 空间；
- 无直接调用 → 无栈帧嵌套；
- 同步由调度器协调 → 无竞争条件；
- 事件无实体 → 零内存开销。

---

### 6.3 “调度器感知语言”的终极愿景

Arxil 将操作系统的调度语义直接编码到语言结构中：
- `push`/`pop` → 调度单元创建/销毁；
- `wait`/`signal` → 调度屏障；
- `pivot` → 跨调度单元共享；
- `capability` → 调度器权限检查依据。

这使得：
- 编译器可生成调度器友好的代码；
- 调度器可基于结构语义优化执行（如亲和性调度）；
- 程序员无需理解底层细节，即可写出高效并发代码。

---

## 总结
AS 计算模型不仅是一种新的执行模型，更是一套从硬件到语义、从内存布局到并发协作的完整计算范式重构。它将“结构”置于计算的核心，使程序的安全性、性能与可组合性成为结构的自然属性，而非附加约束。

---
