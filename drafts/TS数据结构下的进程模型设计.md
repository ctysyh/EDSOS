# TS数据结构下的进程模型设计

> 将**公理化的 Tree-Stacked（TS）结构**作为计算语义的“上层建筑”，与**OS局部视图的三层职责**作为系统实现的“下层基础”进行对齐。目标是构建一个**理论严谨、实现清晰、上下贯通**的分布式操作系统模型。

---

## 一、基于 Tree-Stacked 的进程模型形式化描述

在 TS 的公理体系下，**进程不再是传统意义上的资源容器，而是一个动态演化的 Tree-Stacked 实例**。

### 定义：**进程 = 一个带执行语义的 Tree-Stacked 实例**

更精确地：

> 一个 **进程（Process）** 是一个四元组  
> \[
> \Pi = (\mathcal{T}, \sigma, \mu, \rho)
> \]  
> 其中：
> - \( \mathcal{T} \) 是一个 Tree-Stacked 结构（满足树公理、栈公理、提升公理）
> - \( \sigma : \mathcal{T} \to \text{State} \) 是**执行状态映射**，为每个节点赋予运行时状态（如 RUNNING, BLOCKED, MIGRATING）
> - \( \mu : \mathcal{T} \to \text{PM} \cup \{\bot\} \) 是**位置映射**，指示每个节点当前所在的物理机（PM），\( \bot \) 表示未调度
> - \( \rho \in \mathcal{T} \) 是**当前执行焦点**（execution focus），即逻辑“程序计数器”所在节点（通常是某叶子节点）

### 关键语义解释：

| TS 概念 | 在进程模型中的体现 |
|--------|------------------|
| **节点（node）** | 一个**上下文单元**：可表示函数调用帧、线程、协程、作用域块、分配的内存块 |
| **栈序（\(\preceq\)）** | 同一父节点下的子上下文的**激活顺序**，决定“谁在栈顶” |
| **Lift 操作** | 实现**闭包捕获、指针逃逸、远程引用**——将一个子上下文提升至祖先作用域，使其生命周期超越局部 |
| **根节点** | 进程的入口点（如 `main()`），也是**资源归属与命名空间的锚点** |
| **叶子节点（无子）** | 当前可执行的最小任务单元（类似传统“线程上下文”） |

### 动态行为与OS交互：

- **调度** = 选择一个叶子节点 \( n \in \mathcal{T} \)，设置 \( \mu(n) = \text{PM}_i \)，并令 \( \rho = n \)
- **迁移** = 修改 \( \mu(n) \) 为另一 PM，并触发底层一致性协议
- **分配内存** = 在当前焦点节点 \( \rho \) 上 Push 一个新节点 \( n' \)（代表内存上下文）
- **返回指针** = 对刚分配的 \( n' \) 执行 Lift，将其挂到祖先节点（如调用者）下
- **进程终止** = 销毁整个 \( \mathcal{T} \)，释放所有资源

---

## 二、OS 局部视图与 Tree-Stacked 进程模型的三层对齐

OS 的“局部视图”（Local View）是每台物理机（PM）上运行的 OS 实例，承担三重角色。我们将这三层与 TS 进程模型的操作和状态一一对应：

### 1. **本机调度（Local Scheduling）**  
**目标**：高效执行本机可运行的上下文节点。

| TS 概念 | 本机调度职责 |
|--------|------------|
| 节点 \( n \) 满足 \( \mu(n) = \text{本机} \) 且 \( \sigma(n) = \text{READY} \) | 加入本地调度队列 |
| 栈序 \( \preceq \) | 用于**局部优先级**：栈顶节点优先执行（LIFO，符合函数调用局部性） |
| 执行焦点 \( \rho \) | 由调度器在上下文切换时更新 |
| 节点状态 \( \sigma \) | 由本机 CPU 执行时更新（如 BLOCKED on I/O） |

> **实现**：调度器的输入不再是“线程”，而是“TS节点”。

---

### 2. **跨机协同调度（Cross-PM Coordination）**  
**目标**：处理涉及多PM的 TS 操作（迁移、Lift、远程访问）。

| TS 操作 | 跨机协同机制 |
|--------|-------------|
| **在其他PM push节点** | 若目标位置在另一PM，则：<br>• 本机DPU向目标PM发送“挂载请求”<br>• 建立路径缓存（ref） |
| **迁移节点 \( n \)** | <br>• 本机OS标记 \( \sigma(n) = \text{MIGRATING} \)<br>• DPU执行所有权转移（若 \( n \) 拥有内存）<br>• 目标PM接收并设置 \( \mu(n) = \text{self} \) |
| **远程内存访问** | 访问某节点 \( n \) 拥有的内存 → 触发 DPU 路径缓存协议 |

---

### 3. **单一OS整体决策贡献（Global Consensus Contribution）**  
**目标**：每个局部视图参与集群级决策（如负载均衡、故障恢复、全局GC）。

| 全局问题 | 局部视图如何通过 TS 贡献信息 |
|--------|--------------------------|
| **负载均衡** | 上报本机 TS 中 READY 节点数量、内存占用、DPU带宽压力 |
| **全局死锁检测** | 基于 TS 的依赖图（如A等待B的内存，B等待A的信号）构建局部依赖子图，参与分布式死锁检测 |
| **故障恢复** | 若某PM失效，其他PM遍历其 TS 中被 Lift 过的节点，尝试接管或清理 |
| **资源配额** | 基于本机 TS 中所有节点的内存归属（owner），计算“远程页占用”，确保 ≤ 物理容量 |

> **本质**：每个局部视图维护其**TS子图的完整状态**，并通过轻量协议参与全局决策，无需中心协调者。

---

## 三、上下贯通：从抽象到实现的映射

| 抽象层（自上而下） | 实现层（自下而上） |
|------------------|------------------|
| **Tree-Stacked 进程模型**<br>（公理化结构） | ←→ | **OS 局部视图**<br>（三层职责） |
| 节点（node） | ←→ | 内核中的 `ts_node` 结构体（含上下文、状态、位置） |
| Lift 操作 | ←→ | DPU 驱动发起的“远程挂载”协议 |
| 栈序（\(\preceq\)） | ←→ | 直系祖节点链从尾到头排序即对应入栈顺序 |
| 执行焦点（\(\rho\)） | ←→ | CPU 的当前任务指针 + 编译器插桩的 GVA 访问旁路 |
| 全局 TS 结构 | ←→ | 分布式元数据：由所有PM的局部TS + DPU路径缓存共同隐式维护 |

---

## 四、总结：Tree-Stacked 作为 OS 的统一抽象内核

- **对程序员**：TS 提供了自然的**作用域+并行+共享**语义，无需显式网络或IPC。
- **对OS设计者**：TS 为调度、内存、一致性提供了**统一的操作对象**。
- **对硬件**：TS 的 Lift 和迁移操作**精准匹配 DPU 的路径缓存与所有权协议**。

> **Tree-Stacked 不仅是一个数据结构，更是分布式操作系统的新“细胞”**：  
> 它同时编码了**控制流、数据流、作用域、位置与生命周期**，  
> 使得“显式分布式、隐式通信”的理想，有了坚实的理论与实现基础。