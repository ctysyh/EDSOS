# TS 数据结构下的进程模型设计：基于超TS（Meta-Tree-Stacked）的全结构操作系统模型

EDSOS 并非传统意义上的操作系统，而是一种**以 Tree-Stacked（TS）结构为唯一原语**构建的**全结构化分布式运行时**。整个系统——包括用户应用、驱动、协议栈、调度器、安全策略——均组织为一个动态演化的 **超TS（Meta-Tree-Stacked）**，其中每个子树代表一个逻辑服务或执行上下文，通过**结构化共享、事件驱动、作用域隔离**实现高效协同。

本模型融合了 microkernel 的安全性与 monolithic kernel 的性能，并通过 **ABI 内联 + CTRN 共享 + 无中心调度**，超越了 hybrid kernel 的历史局限。

---

## 一、超TS：整个系统的统一结构表示

### 定义：超TS = 所有 TS 的并集

在 EDSOS 中，**不存在“内核地址空间”与“用户地址空间”的二分**。整个系统由若干 **TS** 构成，它们逻辑上共同组成一个 **超TS（Meta-TS）**。
每个TS都是“一等公民”：用户 TS 与系统服务组件 TS、驱动 TS 在结构上完全对等，仅权限与 capability 不同。

### 核心原则

- **无 Kernel Process**：狭义内核（内存映射、TLB 管理、CPU 上下文切换）以**裸金属形式**直接运行，不表现为任何 TS 节点；
- **所有服务即 TS**：文件、网络、驱动、授权等均为独立 TS 子树；
- **通信即结构操作**：跨 TS 协作通过 **CTRN 共享、链式消息、EDSOS Event** 实现，而非传统 IPC；
- **调度即焦点迁移**：执行焦点（ρ）在超TS中动态迁移，由每个 CPU Core 的本地调度器驱动。

---

## 二、TS：进程实例的结构化表达

### TS Node 作为一个**可独立执行、独立调度的原子**

- 在 EDSOS 中，一个 TS 节点（Tree-Stacked Node）是一个可独立执行、独立调度的原子，它在*虚拟地址连续*的若干 VPs（Virtual Pages）中，包括必要的元数据、*应当*作为一个完整的逻辑段落的指令段、和对应于指令段的数据段。
- 它既对应于一个简化、微缩的进程空间，又对应于一个函数的指令流及其内存栈；允许一种退化的TS节点不具有指令段或者指令段不包含程序的主要逻辑，而主要承载了一些生命周期需要逃逸的数据，主要对应于传统概念的“*一块*堆内存”。
- 在原生模式下符合EDSOS Standard ABI的进程代码中，节点的进入和退出是有专用ABI显式标明的，大概对齐了单个复杂函数或有限个执行顺序和跳转关系固定的简短函数；在退化模式下的普通进程代码中，节点的粒度主要是对齐了线程的粒度。

### TS Node 及其动态演化构成 TS 及其动态演化

- 同一个进程的所有节点构成TS结构，TS的框架是在进程代码从磁盘加载进内存期间初步搭建起来，并在运行时丰满、不断演化的。
- 除了整棵 TS 的根节点作为特殊节点、包含了对应于传统 OS 的 PCB 数据之外，其他节点均没有ID或序号类似物，仅通过父子指针组织起来。

### CTRN：遵守结构的 TS 联结
- **跨TS引用节点（Cross TS Referring Node, CTRN）**是一个退化的节点。
- 更详细地，它在声明周期中会被 push 一次，触发者显然是某个 TS 的某个节点 A，此时这个 CTRN 就是节点 A 的子节点并注册到全局命名表；
- 接着，其他任何一棵 TS 的节点都可以在命名表中查询并连接到这个 CTRN，但是同一棵 TS 不能连接两次（两个不同节点同时连接）同一个 CTRN，这个 CTRN 在每棵 TS 内可以独立地 lift 和 pop，以便一个 TS 的多个节点可以正确地访问到它并在恰当的时候取消连接；
- CTRN 在被 pop 的时候需要检查引用计数，当引用计数为0时触发资源释放。
- lift 操作对于 CTRN 的语义和所有其他正常节点都是相同的，即把自己的子节点变成自己的父节点、自己继承被lift对象的原有子节点、被lift对象继承自己的原有父节点；**lift的作用是使得这个节点的生命周期可以超过自己并且让自己可以访问其中的数据**，回顾TS的精确定义我们就知道，一个节点的*定义域*（即可以访问的范围）是这个节点本身及其**直系祖节点链**，而*作用域*（即这个节点的数据对谁可见）是以这个节点为根的子树；因此，当前节点 push 了一个子节点然后 lift 它，它就变成了当前节点的父节点可以被当前节点访问，如果有多个节点都要访问这个新建的节点，那么就需要让这个新建节点成为它们的公共祖节点。
- 这样，一个CTRN在不同的TS中可以处在不同的内部位置，比如在某一个TS中被一路lift到了根节点下（根节点就不再能继续lift越过了）、对这个TS的所有普通节点可见，但在另一个TS中只被lift了一次、只对那里的一个节点可见，这个是TS内部的结构，不会对于CTRN本身及其共享状态造成影响。

---

## 三、EDSOS 是 microkernel 吗？

- **是的?**：  
  系统逻辑分为 **狭义 Kernel（裸金属）** 与 **服务组件（TS 子树）**，服务以“进程”形式隔离运行，具备 microkernel 的**安全边界**与**模块化扩展性**。

- **不是?**：  
  不存在 **Kernel Process**。狭义 Kernel 不表现为任何 TS 节点，而是作为 **“硅中介层”**（Silicon Interposer）——  
  所有 TS 通过 **“硅通孔”**（加载期 ABI 内联）直连该中介层，  
  通过中介层内的 **“布线”**（CTRN、链式消息总线、EDSOS Event）实现互连。

- **是超越!**：  
  EDSOS 基于 TS 模型，创造了一种**全新 OS 形态**：
  - 拥有 microkernel 的**安全性**与**可验证性**；
  - 具备 monolithic kernel 的**零跳转性能**；
  - 规避了 hybrid kernel 的**历史包袱**与**隐式共享风险**。

---

## 四、总结：超TS 作为操作系统的“结构 DNA”

EDSOS 的核心洞见是：

> **操作系统不应是一组进程在内核上运行，而应是一个结构化的执行宇宙——其中控制流、数据流、作用域、生命周期、位置信息，全部编码于超TS 的拓扑之中。**

- 对程序员：TS 提供自然的作用域 + 并行 + 共享语义，无需显式网络或 IPC；
- 对系统设计者：TS 为调度、内存、安全、一致性提供统一操作对象；
- 对硬件：TS 的 `lift`、`divide`、CTRN 等操作，精准匹配 DPU 的路径缓存与所有权协议。

**Tree-Stacked 不仅是一个数据结构，更是分布式操作系统的新“细胞”。**  
而 EDSOS，正是由这些细胞构成的**活体系统**。