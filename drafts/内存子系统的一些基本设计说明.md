# 内存子系统的一些基本设计说明

- 就像经典OS中虚拟地址空间本身的64位指针值不包含进程的页表基址一样，**GVA本身不包含TSID**，但是当我们使用不同的TSID（哪怕搭配相同的LVA），DPU映射出的GVA是**无关的**。在GVA的初始设置中采用PMID（机器ID）加上LVA的设计，是目前看来一个比较可行的方案，不仅保证了（同TS内）全局（全集群）无冲，而且在初始阶段达成了*GVA 与 LVA 必须保持局部连续的一一对应*的要求。
- “跨节点指针传递”和“跨节点指针算术”是两个不相同的问题。“跨节点指针传递”就像使用指针在不同线程中访问同一个共享变量，而“跨节点指针算术”就像在前者基础上通过指针运算访问共享变量的特定字段。前者在节点作用域的约束下是被允许的，而后者**有可能超出被指向的节点的范围**，就像使用指针访问字符串而指针运算超过了缓冲区长度的风险存在一样。但后者的超出范围如果是超出节点范围，仍然可以被捕捉；但如果是代码逻辑失误超出变量范围、或（小概率地）LVA巧合连续地延续到另一个有效可访问节点，则无法捕捉。
- 节点包含元数据段、指令段、数据段三段，节点内虚拟地址的连续性**涵盖了整个节点的三个部分**。三个部分**各自**会向上对齐到完整页，并各自具有不同的访问权限：（对于应用代码来说）元数据段只读、指令段可读可执行、数据段可读可写。
- *节点*是属于进程子系统的概念，内存子系统本身不需要掌握*什么是节点*和*节点的边界*，它只会按照进程子系统的要求设定一段连续的VP、并在需要的时候设定其PTE。
- 虽然内存子系统不解释节点、不解释为什么会出现三段整体连续但各自权限不同的已映射虚拟地址，但是进程子系统仍可以按照*数组形式*传参，类似于`[{virtual_space_size, prot_mask}]`形式，其中`virtual_space_size`是这一段虚拟地址所需的大小（向上对齐到整数页），`prot_mask`是这一段虚拟地址的权限标识掩码。这样内存子系统可以在其中尝试使用大页。
- `merge`和`divide`操作都是重映射，但都跟简单的重映射有区别。对于`merge`来说，它把两个节点合并为一个节点，因此可以释放掉其中一个节点的元数据段的物理和虚拟空间，但需要一个新的、更大的连续虚拟空间；对于`divide`来说，它把一个节点拆分为两个节点，需要注意的是拆分进行在数据段和指令段、且拆分是近似随机拆分的（语义驱动，内存子系统没有任何先验），还额外需要增加一段物理和虚拟空间来新增一个元数据段，但只需要两个更小的连续虚拟空间。
- 