# 节点状态机

---

## 一、表格总览

### 状态列表

| 状态 | 含义 |
|------|--------|
| `ready` | 就绪等待调度 |
| `running` | 正在执行 |
| `block` | 阻塞 |
| `zombie` | 临终 |
| `error` | 错误 |

### 操作列表

| 操作 | 触发者 | 目标状态 | 是否需中间状态 | 并行影响 | 关键协同 |
|------|--------|----------|----------------|----------|----------|
| `push` | 父节点 / 编译器桩 | → ready | 否 | 无（叶子创建） | 内存子系统（VP 分配） |
| `active` | 调度器 | ready → running | 否 | 核心级调度 | TLB 预热、祖链重建 |
| `wait` | 节点自身 / 资源管理器 | running → block | 否 | 无 | 事件通知机制 |
| `lift` | 节点自身 / 协议 | 结构变更 | 存在但无需显式标识 | 需 pause 子孙 | DPU、祖链更新 |
| `merge` | 内存管理器 | 结构变更 | 存在但无需显式标识 | 需 pause 自身 | 虚拟重映射 |
| `divide` | 内存管理器 | 结构变更 | 存在但无需显式标识 | 需 pause 自身 | 数据迁移 |
| `pause` | 调度器 / 中断 | running → ready | 否 | 核心级 | TLB 刷新、上下文保存 |
| `finish` | 节点自身 / 回调 | → zombie | 否 | 无 | 子树清理 |
| `pop` | 父节点 | zombie → 回收 | 否 | 无 | 引用计数 |
| `warn` | 安全监控 / Fault Handler | → error | 否 | 全局终止 | 安全审计 |

> **关键共识**：**所有操作要么原子成功（进入目标状态），要么失败回滚（不改变状态）**。中间状态仅在**结构变更需异步生效**时引入，但可通过 `pause` 机制规避。

---

## 二、逐操作深度分析

### 1. `push`：原子创建，无中间态

- **语义**：创建新叶子节点，挂载为当前节点的子节点。
- **触发者**：当前 running 节点（如函数调用、线程 spawn）。
- **原子性保证**：
  - 内存子系统必须 **一次性分配所有 VPs**；
  - 若 VP 不足 → 返回错误，不创建部分节点；
  - 跨机 push：目标 PM 完成 VP 分配 + 祖先链验证后，才返回成功。
- **并行性**：多个核心可并发 push 不同父节点的子节点，无冲突。
- **无需中间态**。

---

### 2. `active`：调度器驱动的上下文激活

- **语义**：将 ready 节点调度到 CPU 核心执行。
- **关键点**：
  - **不限于叶子节点**：父子可并行（如协程 + 主线程）；
  - **调度器责任**：
    1. 选择 ready 节点；
    2. 重建其祖先链（通过父指针遍历）；
    3. **增量 TLB 预热**（L1: 自身；L2: 祖先）；
    4. 加载寄存器上下文；
    5. 切换到 running。
- **失败处理**：
  - TLB 预热失败（罕见）→ 标记 error，尝试下一节点；
  - 无 ready 节点 → 进入 idle。
- **并行模型**：同片/跨片核心调度逻辑一致，仅 TLB 预热延迟不同。

---

### 3. `wait`：阻塞与事件驱动唤醒

- **语义**：节点主动放弃 CPU，等待某事件（I/O 完成、锁释放等）。
- **实现机制**：
  - 节点调用 `edsos_wait(event_id)`；
  - EDSOS 将节点加入 **event_id 的等待队列**；
  - 状态转为 block；
  - 当事件发生，**事件管理器**遍历队列，将节点状态转为 ready。
- **关键要求**：
  - **唤醒必须精准**：避免虚假唤醒（spurious wakeup）；
  - **无竞态**：wait 与 event_signal 需原子协调（通过内存子系统事件总线）。
- **并行性**：多个节点可 wait 同一事件，无冲突。

---

### 4. `lift`：结构变更，需 pause 子孙

- **语义**：将节点挂载到更高祖先下，改变其作用域。
- **无需中间状态**，但需 **pause 所有子孙节点**。
- **详细流程**：
  1. 节点发起 lift(target_ancestor_gva)；
  2. EDSOS 验证 target_ancestor 在 TS 树中（通过 GVA 遍历）；
  3. **暂停所有子孙节点**（递推调用 `pause`）；
  4. 原子更新父指针；
  5. 子孙节点状态仍为 ready，但下次 active 时将使用新祖链。
- **为什么无需 lift_pending**？
  - 因为 **作用域变更对子孙不可见，直到它们被重新调度**；
  - TLB 是 per-core 的，旧核心的 TLB 仍有效，直到被刷新；
  - **安全由调度器保证**：子孙下次运行时，TLB 预热基于新父链。
- **跨机 lift**：DPU 传输新挂载点，目标 PM 执行相同 pause + 更新；通过代理根节点（缓存本机子树的根节点之上的信息，接收其他 PM 发来的作用到本机子树根节点的直系祖节点链的结构变更消息）和代理子节点（缓存本机父树的从一个节点开始的子树在其他 PM 的信息，接收其他 PM 发来的从子树向上作用到这个节点的结构变更消息）来在每个 PM 中缓存信息，减少频繁跨机访问开销。

---

### 5. `merge`：扩容操作，需 pause 自身

- **语义**：将自身与一个“扩展子节点”合并，扩大虚拟地址范围。
- **流程**：
  1. 先 `push` 一个扩展子节点（仅数据段）；
  2. 调用 `merge(child_gva)`；
  3. **pause 自身**（若 running）；
  4. 内存子系统 **虚拟重映射**：将 child 的 VPs 合并到父的地址空间；
  5. 更新 `vbase/size`；
  6. 子节点标记为 zombie；
  7. 自身状态仍为 ready（若原为 ready）或 running（下次调度恢复）。
- **关键**：merge 期间，**自身不能执行**，故需 pause。
- **无需 merge_pending**：因操作在 pause 保护下原子完成。

---

### 6. `divide`：分裂操作，需 pause 自身

- **语义**：将部分数据分裂为新子节点，用于回收或 Lift。
- **流程**：
  1. **pause 自身**；
  2. 内存子系统分配新 VPs；
  3. 迁移数据；
  4. 创建新子节点（状态 ready）；
  5. 更新自身 `vbase/size`；
  6. 恢复状态。
- **典型场景**：冷数据回收 → divide → lift 到全局缓存池。

---

### 7. `pause`：中断驱动的上下文冻结

- **语义**：将 running 节点暂停，保存上下文，回到 ready。
- **触发场景**：
  - 定时器中断（时间片到期）；
  - TLB 一致性中断（跨核 TLB 刷新）；
  - 调度器主动抢占；
  - lift/merge/divide 需要暂停。
- **操作**：
  - 保存寄存器；
  - 状态 → ready；
  - **不清空 TLB**（下次 active 可复用，除非祖链变更）。

---

### 8. `finish`：正常退出

- **语义**：节点执行完毕，进入 zombie。
- **触发**：`return` 或 `edsos_exit()`。
- **行为**：
  - 状态 → zombie；
  - 若有子节点，**递归 finish**（TS 子树语义）；
  - 父节点可 later `pop`。

---

### 9. `pop`：父节点回收子节点

- **语义**：父节点显式回收已 zombie 的子节点。
- **原子性**：检查子节点状态 == zombie → 释放内存 → 删除父指针。
- **跨机 pop**：发送 DPU unref，目标 PM 回收。

---

### 10. `warn`：安全异常

- **语义**：强制进入 error 状态，终止子树。
- **触发**：
  - Page Fault 验证失败（访问非法地址）；
  - 元数据 magic 错误；
  - DPU 消息签名无效。
- **行为**：
  - 状态 → error；
  - **递归 error 所有子孙**；
  - 上报安全日志；
  - 父节点可选择 ignore 或 terminate。

---

## 三、关于并行模型的再确认

> **同片多核 vs 跨片多核在 EDSOS 中无本质区别，只有延迟差异**。

- EDSOS 的设计目标就是 **“统一并行模型”**：
  - 所有核心（无论物理位置）共享 **全局 GVA 空间**；
  - 内存子系统接口 **不区分本地/远程核心**；
  - 差异仅体现在内存访问延迟。
- 这意味着：所有操作的设计 **无需为“跨片”特化逻辑**，只需容忍更高延迟。

---