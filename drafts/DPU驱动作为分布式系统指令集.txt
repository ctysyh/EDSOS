这是一个关键的系统集成问题：**DPU驱动必须成为Tree-Stacked（TS）进程模型与底层硬件协议之间的“语义桥梁”**。它不是传统意义上的设备驱动（如网卡驱动），而是一个**分布式系统原语的执行引擎**，既要暴露足够底层的能力以支撑TS操作，又要提供足够抽象的接口以保证OS调度器的灵活性。

我们将从**设计原则、核心API、协议映射、状态管理、扩展机制**五个维度，构建一个**基础性、原语性、完备性、扩展性兼备**的DPU驱动模型。

---

## 一、设计原则：驱动作为“分布式系统原语执行器”

| 原则 | 说明 |
|------|------|
| **基础性** | 驱动只实现**不可再分的分布式原语**（如ref、unref、transfer_ownership），不包含策略（如调度、GC） |
| **原语性** | 每个API对应一个**原子语义操作**，可被TS操作直接映射 |
| **完备性** | 覆盖TS模型所需的所有跨机交互：内存访问、节点迁移、作用域提升、故障恢复 |
| **扩展性** | 支持未来协议扩展（如新一致性模型、加密路径）而不破坏现有API |

> 💡 **驱动 = DPU硬件能力 × TS语义的最小交集**

---

## 二、DPU驱动核心API（面向OS内核）

所有API以**异步、事件驱动、零拷贝**为默认模式，返回**操作句柄**用于后续查询或取消。

### 1. **内存可见性管理（支撑TS的“作用域”语义）**

```c
// 建立对远程GVA区域的引用（对应TS中“访问祖先/子节点的内存”）
dpu_op_t dpu_ref_gva(GVA_t gva, size_t len, PM_ID_t owner_pm);

// 解除引用（TS节点销毁或作用域退出时调用）
void dpu_unref_gva(GVA_t gva, size_t len);

// 查询当前GVA的路径缓存状态（用于调试或优化）
dpu_ref_state_t dpu_query_ref(GVA_t gva);
```

> ✅ **语义**：`dpu_ref_gva` 是TS中“节点可见性”的硬件实现。  
> - 若GVA属于本机TS中的某节点，则自动触发路径缓存建立  
> - 驱动维护 `GVA → (owner_pm, ref_count)` 映射表

---

### 2. **所有权转移（支撑TS的“Lift”和“迁移”）**

```c
// 将GVA区域的所有权从当前PM转移至target_pm
// 用于TS节点迁移或Lift到远程祖先
dpu_op_t dpu_transfer_ownership(GVA_t gva, size_t len, PM_ID_t target_pm);

// 声明本机为某GVA区域的新所有者（接收端调用）
void dpu_claim_ownership(GVA_t gva, size_t len);
```

> ✅ **语义**：`dpu_transfer_ownership` 是TS **Lift** 和 **迁移** 操作的底层协议触发点。  
> - 驱动确保转移期间所有ref持有者收到Invalid  
> - 接收方调用 `claim_ownership` 后，可安全修改该GVA

---

### 3. **TS节点生命周期同步（支撑进程模型）**

```c
// 通知DPU：某TS节点（由GPN标识）已创建/销毁
void dpu_notify_node_lifecycle(GPN_t gpn, enum { NODE_CREATE, NODE_DESTROY });

// 查询某GPN是否在远程PM上活跃（用于跨机调度决策）
bool dpu_is_node_alive(GPN_t gpn, PM_ID_t remote_pm);
```

> ✅ **语义**：将TS的**结构变化**转化为DPU的**元数据更新**。  
> - `NODE_DESTROY` 触发自动 `unref` 所有该节点拥有的GVA  
> - 驱动维护 `GPN → (home_pm, current_pm)` 表，供路径缓存使用

---

### 4. **原子操作与同步（支撑TS中的共享状态）**

```c
// 远程原子操作（基于路径缓存协议）
uint64_t dpu_atomic_fetch_add(GVA_t gva, uint64_t val);

// 分布式屏障（可选，用于TS Scope节点的集体同步）
dpu_op_t dpu_barrier(GPN_t scope_gpn, list<PM_ID_t> participants);
```

> ✅ **语义**：为TS中**跨节点共享的ContextFrame**提供同步原语。

---

### 5. **故障与恢复（支撑TS的鲁棒性）**

```c
// 注册PM故障回调（当DPU检测到某PM失联）
void dpu_register_pm_failure_handler(void (*handler)(PM_ID_t failed_pm));

// 清理某PM相关的所有路径缓存和ref（由故障处理器调用）
void dpu_cleanup_pm_refs(PM_ID_t failed_pm);
```

> ✅ **语义**：TS的**全局结构**依赖DPU的**故障感知能力**。

---

## 三、API与TS操作的精确映射

| TS 操作 | 触发的DPU驱动API |
|--------|------------------|
| 访问远程GVA（如 `*ptr`） | 编译器插桩 → `dpu_ref_gva`（若首次访问） |
| 函数返回指针（Lift） | `dpu_transfer_ownership` + `dpu_notify_node_lifecycle` |
| 线程迁移 | `dpu_transfer_ownership`（迁移其栈） + 更新 `current_pm` |
| 进程终止 | 遍历TS → 对每个owned GVA调用 `dpu_unref_gva` |
| 跨进程共享（CPC） | `dpu_ref_gva` + 全局引用计数（由OS维护） |

> 🔁 **驱动不解释“为什么”，只执行“做什么”**——策略由OS调度器决定。

---

## 四、驱动内部状态管理

驱动维护三张核心表（均支持快速查找与并发更新）：

| 表 | 键 | 值 | 用途 |
|----|----|----|------|
| **Ref Table** | GVA | `(owner_pm, ref_count, last_access)` | 路径缓存元数据 |
| **Node Table** | GPN | `(home_pm, current_pm, state)` | TS节点位置跟踪 |
| **Op Table** | op_id | `(status, callback, context)` | 异步操作跟踪 |

> 🛠️ **实现要点**：
> - 使用**无锁哈希表**（如Cuckoo Hashing）保证高并发
> - Ref Table 条目带TTL，避免内存泄漏
> - 所有表更新通过DPU中断或轮询批量处理

---

## 五、扩展性设计：协议插件机制

为支持未来一致性模型（如因果一致性、加密路径），驱动采用**协议插件架构**：

```c
struct dpu_protocol_ops {
    int (*ref)(GVA_t, size_t, PM_ID_t);
    int (*unref)(GVA_t, size_t);
    int (*transfer)(GVA_t, size_t, PM_ID_t);
    // ...
};

// 注册新协议（如 "secure_path_v2"）
void dpu_register_protocol(const char* name, struct dpu_protocol_ops* ops);

// 创建GVA时指定协议（可选）
GVA_t dpu_alloc_gva_with_protocol(size_t len, const char* protocol_name);
```

> ✅ **默认协议** = 路径缓存 + 所有权转移  
> ✅ **新协议** 可复用现有API语义，仅改变底层实现

---

## 六、完备性验证：覆盖TS所有跨机场景

| TS 跨机场景 | 驱动是否支持 |
|------------|-------------|
| 本地访问远程内存 | ✅ `dpu_ref_gva` |
| 远程写（所有权在别处） | ✅ 触发Invalid + `dpu_transfer_ownership` |
| 节点Lift到远程祖先 | ✅ `dpu_transfer_ownership` + `dpu_notify_node_lifecycle` |
| 节点迁移到新PM | ✅ 同上 |
| 进程间共享内存（CPC） | ✅ `dpu_ref_gva` + OS引用计数 |
| PM故障后恢复 | ✅ `dpu_cleanup_pm_refs` + 故障回调 |
| 全局原子操作 | ✅ `dpu_atomic_fetch_add` |

> ✅ **完备性达成**：所有TS跨机语义均有对应的驱动原语。

---

## 七、结语：DPU驱动作为“分布式系统指令集”

该驱动设计实现了：

- **基础性**：仅暴露ref/unref/transfer等不可再分原语  
- **原语性**：每个API对应TS的一个语义操作  
- **完备性**：覆盖TS模型所有跨机交互  
- **扩展性**：通过协议插件支持未来演进  

> **DPU驱动不再是“设备接口”，而是分布式OS的“系统调用层”**。  
> 它使得Tree-Stacked进程模型的优雅语义，得以在硬件上高效、可靠地执行——  
> 这正是“显式分布式单一系统”得以成立的**最后一块基石**。