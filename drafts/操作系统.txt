
去虚拟化（“面向硬件”）
通过“绑定”，将各个进程的逻辑内存空间直接映射到特定的物理内存地址，并且通过编号以及惰性读写适应同一个物理内存地址对应的多个不同进程的逻辑内存空间。
当然，逻辑实现和物理实现不得不因为性能原因截然不同，例如通过尽可能地把堆的某些部分放入栈中并且允许栈非常大以实现指针安全和高效访存，在这个过程中允许栈从其底部甚至中间的某两层之间增加一层，显然这不可能应用到物理实现中以避免整个栈都需要变动。但是每次发生这样的情况，都只需要在局部增加一个跳跃，甚至可以在之后的读写操作中改变跳跃的地点把哪怕跳了一下以不那么影响的地方作为跳跃发生的地方。
在这里，内存模型变为三层：进程（语言层）的逻辑内存空间、内核的虚拟化内存、物理内存。当进程在它的逻辑内存空间中使用了一块堆内存时，内核并非通过诸如maple tree之类的数据结构选取一个物理内存地址返回，而是在虚拟化内存中新建一层（或多层）栈。虚拟化内存中的栈的建立也可以由基址指针的修改触发。虚拟化内存中原则上一个栈帧在同一个内存页中。
虽然在进程看来（从对象的角度来看），是进程将某些特定的地址通过OS申请为自己使用，但是从硬件的角度来讲，无非就是读取一条指令，然后根据指令访问某个特定的物理地址。当物理地址切实地被当成逻辑地址、同时根据编号（状态）被对应的进程使用时，特别是还进行了堆调用栈化时，“在物理内存中查找逻辑地址对应的地方”的需求已经不复存在，所有访存要么严格局部化，要么是超大块内存块的二级指针（二级指针本身同样满足严格局部性）。
这样，还改变了传统的进程模型和内存模型的依赖关系，变为进程模型依赖（从属）于内存模型。

磁盘的直接利用
通过逻辑线程切换，将高带宽高延迟的SSD直接访问的请求延迟隐藏在运行其他逻辑线程的时间内，避免将其数据复制入内存。
同时在切换线程时预发送SSD读取指令，预取下一个时间片将会处理的线程的逻辑内存空间

MessageRing通讯


