# 内存子系统的设计思路

EDSOS 内存子系统最精微的结构：**地址空间的双重性**（LVA/GVA）、**数据的物理实在性**（PP）、以及**一致性协议的层次分离**（PM 内 vs PM 间）。下面系统化地梳理这一逻辑，并明确其对内存子系统设计的深层含义。

---

## 一、核心洞察：VP 的双重身份与 PP 的单一实在

### 1. **VP 是“协议层的幽灵”，PP 是“物理层的实体”**

- **VP 没有物理位置**，它只是一个**身份标识**（TSID + LVA / GVA）；
- **PP 有唯一物理位置**（GPA = PMID + LPA），是电荷的容器；
- **VP 通过“盛装”关系绑定到 PP**，但一个 PP 可被多个 VP 共享（即多个 TSID+LVA 指向同一 PP）。

> **关键结论**：
> **数据的一致性问题，本质上是多个 VP 对同一 PP 的并发访问问题**。
> 而“是否需要显式一致性协议”，取决于这些 VP 是否位于**同一 PM**。

---

### 2. **LVA 与 GVA 的角色分离**

| 维度 | LVA（Local Virtual Address） | GVA（Global Virtual Address） |
|------|----------------------------|------------------------------|
| **使用者** | 本地 CPU（通过 MMU） | DPU（通过协议引擎） |
| **索引上下文** | TSID + 本地页表 | TSID + DPU 全局映射表 |
| **物理映射目标** | LPA（= GPA 后半） | GPA（= PMID + LPA） |
| **作用域** | 单 PM 内 | 全集群 |
| **生成规则** | 由 TS 节点分配，仅需局部连续 | 由初始分配 PM 的 PMID + LVA 构造，含副本掩码 |

> **关键发现**：  
> **LVA 的值与跨 PM 共享完全无关**——它只是 TS 内部的“本地指针”，其唯一约束是“节点内连续”。  
> 跨 PM 共享的语义由 **GVA 的副本掩码** 和 **DPU 协议** 实现，与 LVA 无关。

### 3. 根本视角：**三层本体论（Tripartite Ontology）**

EDSOS 内存子系统建立在三个正交但耦合的实体层之上：

| 层级 | 实体 | 角色 | 关键属性 | 管理者 |
|------|------|------|----------|--------|
| **物理层** | **PP**（Physical Page） | 数据的物理容器 | - GPA（全局物理地址）<br>- 状态（Stable / Free / In-Transit）<br>- 盛装的 VP 列表 | 硅中介层（每 PM 本地） |
| **协议层** | **VP**（Virtual Page） | 数据的逻辑身份 | - VPID = {TSID, LVA}<br>- 所有权（Owner PMID）<br>- 副本列表（Replica PPIDs）<br>- 一致性策略（路径缓存 / 所有权） | DPU 网络（VP Directory） |
| **逻辑层** | **节点**（TS Node） | 执行与结构的单元 | - 父子指针（拓扑）<br>- 逻辑引用计数 | 调度器（每 PM 本地） |

> **核心关系**：
> - **节点 → VP**：通过 LVA 在 TS 上下文中索引；
> - **VP → PP**：通过“盛装”关系绑定物理位置；
> - **PP → 节点**：无直接指针，仅通过 VP 间接关联。

---

## 二、PM 内共享 vs PM 间共享：一致性协议的分层

### 1. **PM 间共享（跨机）：显式 DPU 协议**

- **场景**：CTRN 被两个不同 PM 的 TS 共享。
- **物理布局**：
  - PM₁：PP₁（GPA₁ = PMID₁ + LPA₁），VP₁ = {TSID₁, LVA₁}
  - PM₂：PP₂（GPA₂ = PMID₂ + LPA₂），VP₂ = {TSID₂, LVA₂}
- **一致性机制**：
  - DPU 维护 **GVA₁ ↔ GPA₁** 和 **GVA₂ ↔ GPA₂** 的映射；
  - GVA₁ 与 GVA₂ **除副本掩码外完全相同**，标识“同一逻辑数据”；
  - 读写操作触发 DPU 协议实现一致性。
- **CPU 访问路径**：
  - TSID₁ 访问 LVA₁ → 本地 PTE → LPA₁ = PP₁；
  - TSID₂ 访问 LVA₂ → 本地 PTE → LPA₂ = PP₂；
  - **DPU 在后台同步 PP₁ 与 PP₂ 的内容**。

> **注意**：这不是“零拷贝”，而是“多副本 + 协议同步”——这是分布式系统的必然代价。想要真正的零拷贝，除非直接把寄存器指令发给 DPU、DPU 转发给所有者、所有者的 CPU 执行，这样迁移到不同 PM 就完全没有意义了，处理压力还是堆在同一个 CPU 上。

---

### 2. **PM 内共享（同机）：隐式硬件一致性**

- **场景**：同一 PM 内两个 TS 共享一个 CTRN。
- **物理布局**：
  - **仅一个 PP**（GPA = PMID + LPA）；
  - VP₁ = {TSID₁, LVA₁}，VP₂ = {TSID₂, LVA₂}；
  - 两者 **盛装于同一 PP**。
- **一致性机制**：
  - 依赖 **通用的 CPU 缓存一致性协议**（如 MESI）；
  - 本地 PTE 直接映射到同一 LPA。
- **CPU 访问路径**：
  - TSID₁: LVA₁ → PTE₁ → LPA → PP；
  - TSID₂: LVA₂ → PTE₂ → LPA → PP；
  - **硬件自动保证缓存一致性**。

---

## 三、内存一致性 vs 事件同步：互补而非重叠

> **内存子系统提供数据一致性，进程子系统（EDSOS Event）提供执行同步**。

### 1. **内存一致性（Memory Consistency）**
- **目标**：确保多个 CPU/DPU 对同一 PP 的读写**最终看到相同值**；
- **机制**：DPU 协议（跨机） / 缓存一致性（同机）；
- **粒度**：Page；
- **被动触发**：由内存访问隐式驱动。

### 2. **事件同步（Event Synchronization）**
- **目标**：控制**代码执行顺序**，避免竞争条件；
- **机制**：EDSOS Event（基于调度器链式消息总线的消息传递）；
- **粒度**：节点（逻辑控制流）；
- **主动触发**：显式 wait/signal。

### 3. **二者关系**
- **内存一致性是事件同步的基础**：  
  若 PP 数据不一致，Event 的状态机将崩溃。
- **事件同步减少内存一致性开销**：  
  通过互斥访问避免多写者竞争，从而**减少 DPU 协议触发碰撞路径的次数**。

---

## 四、节点与 LVA 的“重新耦合”——结构坐标的绑定

### 1. **LVA 作为 TS 树的“结构坐标”**

- 在一个 TS 实例中，**整个虚拟地址空间就是这棵树的线性嵌入**；
- 每个节点占据一段连续 LVA；
- **父指针 = 父节点的 LVA 起始地址**；
- **子指针 = 子节点的 LVA 起始地址**；
- 因此，**遍历 TS 树 = 遍历 LVA 空间中的指针链**。

> **TS 的拓扑结构被编码在 LVA 指针中**。

> **为什么必须用 LVA？**
> - **调度器需要快速重建祖先链**：
>   - 从当前节点 LVA 出发，通过父指针（LVA）逐级向上；
>   - 直到根节点（PID 所在处）；
>   - 此过程必须在本地 PM 内完成，**不能依赖 GVA 或 DPU**。
> - **TLB 预热依赖 LVA 连续性**：
>   - 调度器预热“自身 + 祖先”的页，这些页在 LVA 空间中是离散但可通过指针链访问的；
>   - 若父指针不是 LVA，预热无法进行。

### 2. **关键边界：LVA 耦合 ≠ VP 耦合**

这才是理解的核心：

| 维度 | 节点与 LVA 的关系 | 节点与 VP/PP 的关系 |
|------|------------------|----------------|
| **性质** | **结构标识**（Where am I in the tree?） | **资源绑定**（Where is my data stored?） |
| **稳定性** | **创建后不变**（除非 lift 改变父指针） | **可动态变更**（merge/divide/migrate） |
| **作用域** | **TS 内全局唯一** | **可跨 TS 共享**（CTRN） |
| **访问方式** | 是逻辑上的访问，通过指针解引用 | 是物理上的访问，通过页表翻译（MMU 介入） |
| **跨 PM 意义** | **无**（LVA 在其他 PM 无意义） | **有**（VP 通过 GVA 全局标识） |

> **LVA 是节点在“自己所在世界”（TS 虚拟地址空间）中的门牌号；VP 是这个门牌号对应的“房间”在物理世界（PP）中的位置索引**。

- 你可以搬家（VP 从 PP₁ 迁移到 PP₂），但门牌号（LVA）不变；
- 兄弟姐妹按门牌号（LVA）找你，不管你的房间（PP）现在在哪个城市（PM）。

### 3. **对跨 PM 场景的影响：代理节点如何工作？**

当 TS 子树被迁移到另一个 PM 时：

- **父节点的 LVA 不变**（TS 虚拟地址空间稳定）；
- **子指针（LVA）仍指向原孩子的 LVA**；
- 但此时在旧 PM 上，**该孩子节点已经不存在** → 调度器创建 **代理子节点**（Proxy Child Node）；
- **代理子节点的 LVA 被设为与原孩子相同**，但内容仅为元数据缓存、以及跨 PM 消息的缓冲区；
- 这样，**本地 LVA 指针链仍然有效**，调度器可正常遍历。

而在新 PM 中：

- 我们从头构建起一个 LVA 空间（LVA 在不同 PM 中是**无关的**）；
- 子树仍然有祖先，但是祖先的信息浓缩到 **代理根节点**（Proxy Root Node）；
- 所有这些节点被新线性映射到 LVA 空间中，新 PM 的 DPU 创建 TSID + GVA → PMID + TSID + LVA 的映射；
- 代理根节点和在旧 PM 中的代理子节点借助 DPU 管道、通过 TSID + GVA 来跨机互访问。

> **LVA 和 GVA 的稳定性是代理机制可行的前提**。

---

## 五、对内存子系统设计的最终启示

1. **VP 是逻辑标识，PP 是物理实体**：  
   数据必须依附于 PP，VP 只是协议层的“名字”。系统必须知道“电荷在哪”，所有元数据设计必须围绕“VP → PP”的盛装关系展开。

2. **LVA 是 TS 的私有指针，GVA 是 DPU 的公共语言**：  
   二者通过 PMID + TSID 在各自上下文中映射到同一 PP。

3. **一致性协议必须分层**：  
   - 同 PM：依赖硬件，轻量；  
   - 跨 PM：依赖 DPU，显式。

4. **GPRM 三层架构必须保留**：  
   - PP Registry（物理）  
   - VP Directory（协议）  
   - Node Graph（逻辑）
   - 物理层、协议层、逻辑层各司其职，通过“盛装”关系动态耦合，避免紧耦合。

5. **事件系统与内存系统解耦但协同**：  
   内存子系统不实现锁，但为锁的实现提供正确性基础。

6. **显式优于隐式**  
   一致性、迁移、共享均由程序员或策略显式声明，系统不猜测意图。

7. **局部自组织，全局稳态**  
   每个 PM 精确管理本地状态，通过有限预测与协议交互，涌现全局高效。
