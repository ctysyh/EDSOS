# 网络子系统的接收流程

---

## 一、整体架构回顾（关键节点角色）

| 节点 | 所属 TS | 类型 | 作用 |
|------|--------|------|------|
| `skb_node` | `/drivers/net/e1000` | **退化 CTRN 节点** | 封装原始帧，初始仅驱动可见 |
| `ipv4_stack` | `/net/ipv4` | **协议栈服务根** | 处理 IP/TCP，可挂载外部 CTRN |
| `sock_node` | `/net/sockets/sock_0xABCD` | **Socket 状态节点** | 维护连接状态、接收队列 |
| `socket_queue_node` | `/net/sockets/sock_0xABCD/recv_q/0x99` | **接收队列项（CTRN）** | 处理后的应用数据，供用户读取 |
| `user_kpn` | `/user_proc/sysagent/kpn` | **用户 KPN（CTRN）** | 用户 syscall 入口，桥接 socket_queue_node |

> ✅ 所有跨 TS 数据传递均通过 **CTRN 共享挂载** 实现，**无内存拷贝**。

---

## 二、详细流程：从驱动到用户 `recv()`

### 阶段 1：驱动接收帧，创建 `skb_node`

1. **网卡中断触发** → 调度 `/drivers/net/e1000/interrupt_handler`；
2. 驱动从 DMA ring 读取原始帧；
3. 调用 `edsos_push(vp_size, SKB_STUB)` 创建 **退化节点**：
   - **GVA**: `0xDRV_E100_1234_0000`
   - **数据段**: 原始帧（含 L2/L3/L4 头）
   - **指令段**: 极小 stub（仅含 `__free_skb`）
   - **初始状态**: **非 CTRN**，仅驱动 TS 可见；
4. 驱动调用 `edsos_make_ct(node_gva)` → 将其标记为 **CTRN**，生成 **CTRN 元数据**（含权限、引用计数）。

> 🔒 此时 `skb_node` 仍**不可被其他 TS 访问**，直到显式共享。

---

### 阶段 2：共享挂载到协议栈 TS，触发处理

5. 驱动调用 `netif_receive_skb(skb_gva)` → 实际执行：
   ```c
   // 伪代码：向协议栈服务请求处理
   edsos_ct_share(skb_gva, GVA_of_ipv4_stack);  // 共享挂载
   edsos_ct_call(GVA_of_ipv4_rx_entry, skb_gva); // 异步委托
   ```
6. **`edsos_ct_share(src_gva, target_ts_root)` 语义**：
   - 在 `ipv4_stack` 的 CTRN 目录中注册 `skb_gva`；
   - 增加引用计数；
   - **不移动内存**，仅建立 GVA 映射关系；
   - 此后，`ipv4_stack` 及其子节点可安全访问 `skb_node` 数据段。
7. **`ipv4_rx_entry` 被调度**（因其在 `ipv4_stack` 的 Ready Forest 中）；
8. 它调用重用的 Linux 协议栈函数：
   ```c
   ip_rcv(skb_gva);      // 操作 skb_node 数据段
   tcp_v4_rcv(skb_gva);  // 可能 push nf_hook 节点
   ```

> ✅ **关键点**：Linux 代码无需知道 TS，只需操作 GVA 指向的数据段。

---

### 阶段 3：协议栈处理完成，重组为 `socket_queue_node`

9. TCP 层确定该包属于 `sock_0xABCD`；
10. 执行 **`divide` 操作**（EDSOS 原语）：
    - 将 `skb_node` 的 **应用数据部分**（payload）切分为新节点：
      - **GVA**: `0xNET_SOCK_AB_99_0000`
      - **数据段**: 纯 payload（如 HTTP body）
      - **指令段**: 空或极小（仅用于生命周期）
    - 原 `skb_node` 数据段保留 L2-L4 头，用于 ACK 等；
11. 调用 `edsos_make_ct(new_gva)` → 创建 **`socket_queue_node`**；
12. 将其 **挂载到 `sock_node` 的接收队列**（作为子节点）；
13. 调用 `edsos_ct_share(socket_queue_gva, GVA_of_user_kpn)` → **共享给用户 KPN**；
14. `signal(user_recv_event)` → 通知用户可读。

> 📌 **`divide` 是零拷贝的关键**：仅修改 GVA 映射，不复制数据。

---

### 阶段 4：用户调用 `recv()`，通过 KPN 安全读取

15. 用户代码调用：
    ```c
    recv(sockfd, buf, len, 0);
    ```
16. EDSRT 将其重定向到 **`user_kpn`**：
    - `user_kpn` 是用户 TS 的直系祖先（`/user_proc/sysagent/kpn`）；
    - 因此 **用户所有节点均可直接访问 `user_kpn` 的数据段**；
17. **但 `socket_queue_node` 不是用户 TS 的祖先**：
    - 它属于 `/net/sockets/...`，与用户 TS 是“叔侄”关系；
    - **TS 作用域规则禁止直接访问**（即使知道 GVA，TLB 也会拒绝）；
18. **KPN 作为安全代理**：
    - `user_kpn` 的数据段包含一个 **映射槽**（如 `current_packet_slot`）；
    - 当 `socket_queue_node` 被共享给 `user_kpn` 时，**协议栈服务主动将 payload 复制（或映射）到该槽**；
      - 实际是 **GVA 重映射**：`user_kpn->current_packet = socket_queue_gva + payload_offset`；
    - 这一操作由 **内核服务执行**，受 capability 控制；
19. 用户 `recv()` syscall：
    - 调度器将控制流转到 `user_kpn` 的指令段；
    - `user_kpn` 从 `current_packet_slot` 读取 GVA；
    - **验证 `buf` 属于当前 TS**；
    - 执行 **GVA 到用户缓冲区的直接映射**（或小块复制，若跨页）；
    - 返回字节数；
20. 读取完成后，`user_kpn` 通知 `sock_node` → `pop(socket_queue_node)`。

> 🔐 **安全边界**：
> - 用户**永远无法直接访问** `socket_queue_node`；
> - KPN **仅暴露 payload**，不暴露 TCP 控制块、ACK 信息等；
> - 每次 `recv` 仅暴露一个包，防止越界读。

---

## 三、TS 作用域与可见性详解

| 访问者 | 目标 | 是否可见 | 原因 |
|--------|------|--------|------|
| 用户节点 | `user_kpn` | ✅ | 直系祖先 |
| 用户节点 | `socket_queue_node` | ❌ | 非祖先，且无共享 CTRN（仅 KPN 有） |
| `ipv4_stack` | `skb_node` | ✅ | 通过 `ct_share` 显式共享 |
| `sock_node` | `socket_queue_node` | ✅ | 子节点 |
| 驱动 | `skb_node` | ✅ | 创建者 |

> 📜 **EDSOS 可见性规则**：
> - 节点可访问：自身 + 所有祖先 + 显式共享的 CTRN；
> - **KPN 是唯一被授权“中转” CTRN 内容的代理**。

---

## 四、性能与安全双重保障

### 4.1 零拷贝路径
- 原始帧：DMA → `skb_node`（一次）
- Payload：`divide` → `socket_queue_node`（零拷贝）
- 用户读取：KPN 映射 → 用户 buf（可能一次小复制，或 GVA 直接映射）

### 4.2 安全隔离
- 用户无法伪造 `skb_node`；
- 无法访问其他 socket 的 `socket_queue_node`；
- KPN 的映射槽由内核服务写入，用户只读。

### 4.3 扩展性
- `netfilter` 钩子：在 `ipv4_stack` 中 `push` 新节点，处理 `skb_node`；
- 多协议支持：`ipv6_stack`、`udp_stack` 同理；
- 容器隔离：每个容器有独立 `/net` 子树，`ct_share` 仅限内部。

---

## 五、总结：CTRN 共享挂载 + KPN 代理 = 安全零拷贝网络栈

该设计实现了：

- **对 Linux 网络栈的最大兼容**（代码复用）；
- **对 TS 结构的严格遵循**（作用域、CTRN、divide）；
- **对性能的极致优化**（零拷贝、TLB 亲和）；
- **对安全的天然保障**（无隐式共享、KPN 代理）。

这不仅是网络子系统的解决方案，更是 **EDSOS 如何将传统复杂子系统“结构化重构”** 的范式样板。下一步可细化 `ct_share` 的权限模型，以及 KPN 映射槽的多包批处理优化。