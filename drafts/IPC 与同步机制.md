# IPC 与同步机制

---

## 一、设计目标与哲学基础

### 核心原则
1. **无隐式共享**：所有通信与同步必须显式声明。
2. **结构决定权限**：TS 节点的树形结构天然定义作用域与定义域。
3. **调度器驱动**：同步不是靠内存竞争，而是靠调度器对执行顺序的控制。
4. **去中心化**：无全局锁、无共享状态、无中心仲裁者（除命名服务外）。
5. **内存效率优先**：避免不可预估的动态分配，按需创建、及时回收。

---

## 二、核心组件全景图

| 组件 | 职责 | 位置 |
|------|------|------|
| **TS 节点（Tree-Stacked Node）** | 执行单元，拥有指令段、数据段、父子指针 | 用户/内核地址空间 |
| **CTRN（跨 TS 引用节点）** | 退化节点，承载跨 TS 共享数据 | 全局命名表注册，多 TS 共享 |
| **链式消息总线** | 跨 Core 消息传递通道，无锁、SPSC、标签路由 | 调度器之间 |
| **Wait Graph** | 每调度器维护的 `event_name → [blocked_nodes]` 映射 | Per-Core 调度器 |
| **Dependency-Aware Ready Forest** | 就绪队列 + 等待图，实现 O(1) 调度 | Per-Core 调度器 |
| **全局事件注册表** | 跨进程事件的唯一命名服务（DHT 或哈希表） | 系统服务（轻量） |

---

## 三、IPC 机制：基于 CTRN 的结构化共享

### 3.1 CTRN 定义
- **退化 TS 节点**：无主要逻辑，仅含数据段。
- **生命周期**：由引用计数管理，refcnt=0 时释放。
- **作用域**：在每棵 TS 中独立 lift，形成不同树位置，但共享同一数据内容。
- **访问权限**：仅当 CTRN 在节点的**直系祖先链**中时，该节点可访问其数据。

### 3.2 工作流程
1. **创建**：Node A `push(CTRN_X)` → CTRN_X 成为 A 的子节点。
2. **注册**：CTRN_X 注册到全局命名表（DHT）。
3. **lift**：A `lift(CTRN_X)` → CTRN_X 成为 A 的父节点 → A 可访问。
4. **跨 TS 连接**：
   - Node B `lookup("CTRN_X")` → 获得代理。
   - B `push(proxy)` → `lift(proxy)` → CTRN_X 成为 B 的祖先。
5. **断开**：`pop` → refcnt--，refcnt=0 时释放。

### 3.3 特性
- **安全隔离**：TS 作用域不因共享而扩张。
- **零拷贝**：多 TS 共享同一物理内存（通过页表映射）。
- **解耦同步**：CTRN **只负责数据共享**，**不负责顺序控制**。

---

## 四、同步机制：基于 EDSOS Event 的执行顺序屏障

### 4.1 EDSOS Event 本质
- **无实体**：不是内存变量，不是 HANDLE，不是内核对象。
- **概念性屏障**：仅由 `event_name` 标识，表示“等待某条件成立”。
- **存在性**：仅当调度器有至少一个等待者时，在其 Wait Graph 中存在槽位。
- **生命周期**：随等待者出现而创建，随队列清空而回收。

### 4.2 同核同步：Dependency-Aware Ready Forest
- **Wait Graph**：`event_name → FIFO queue of blocked nodes`
- **wait(event)**：
  - 节点加入 Wait Graph 对应队列,不进入就绪队列
- **signal(event)**：
  - 将 Wait Graph 中等待在这个 event 上的一个（或所有）等待者加入就绪队列
- **调度器**：仅从就绪队列取节点 → **O(1) 调度，零轮询**

### 4.3 跨核同步：协商式唤醒
- **本地等待者列表**：每个调度器维护 per-event 等待者（按本地序号排序）
- **释放流程**：
  1. 持有者广播 `QUERY`（通过链式总线）
  2. 有等待者的调度器回复 `RESPONSE`（含 `(core_id, rdtsc_tsc)`）
  3. 持有者按全序选 winner，发送 `GRANT`
  4. winner 唤醒对应节点
- **FIFO 保证**：通过 `(core_id, rdtsc_tsc)` 全序近似实现跨核公平

### 4.4 链式消息总线
- **拓扑**：链表（可扩展为 k-ary）
- **队列**：每个邻居一个 SPSC 无锁环形缓冲区
- **消息**：带标签（tag），查回调表处理
- **接口**：`send(msg, tag)`, `check()`（必须定期调用）
- **优势**：无锁、低开销、可控延迟

### 4.5 跨进程事件
- **命名**：必须全局唯一
- **ID 编码**：最高位区分进程内（0）/跨进程（1）
- **注册**：首次使用时查询全局事件注册表（DHT）
- **局部处理**：与进程内事件完全一致（仅 ID 生成不同）

---

## 五、标准同步原语的实现（用户态库 + syscall）

所有传统同步原语均通过 **EDSOS Event + 用户态状态变量** 实现：

| 原语 | 状态变量位置 | Event 使用 |
|------|------------|-----------|
| **Mutex** | 用户内存（可位于 CTRN） | 1 个 event，FIFO 唤醒 |
| **RWLock** | 用户内存 | 2 个 events（读/写） |
| **Semaphore** | 用户内存 | 1 个 event，每次 post 唤醒 1 个 |
| **Condition Variable** | 与 mutex 共享 | wait 时先 unlock，再 wait event |
| **Barrier** | 用户内存 | 1 个 event，全员到达后 signal |
| **Windows Event** | 用户内存 | 1 个 event + manual/auto 标志 |

> **关键**：状态变量**仅用于逻辑判断**，**同步顺序完全由 Event 机制保证**。

---

## 六、工程特性总结

| 维度 | 特性 |
|------|------|
| **内存开销** | 按需分配，空闲零开销；使用 slab allocator 避免碎片 |
| **处理开销** | wait 零开销，signal 时触发协商；无轮询 |
| **原子操作** | **完全避免**（SPSC 队列 + 本地状态） |
| **扩展性** | 天然支持：同核 → 同 CPU 多核 → 跨 CPU → 跨 PM |
| **确定性** | 严格 FIFO 顺序，调度行为可预测 |
| **安全性** | 无用户态竞态，权限由 TS 结构天然保证 |
| **调试性** | 所有状态可见（Wait Graph、CTRN 位置、消息流） |

---

## 七、总结：EDSOS IPC 与同步机制的范式创新

我们成功构建了一套：

- **以 TS 结构为安全边界**
- **以 CTRN 为数据共享载体**
- **以 EDSOS Event 为执行顺序屏障**
- **以调度器为同步引擎**
- **以链式消息总线为跨核通道**

的全新并发模型。

它彻底摆脱了传统 OS 的“共享变量 + 原子操作 + 内核睡眠队列”范式，实现了：

> **无锁、少原子、无黑盒、无隐式共享、全确定性、硬件友好** 的并发控制。

这不仅是技术实现，更是对操作系统并发本质的**哲学重构**——  
**并发不是资源竞争，而是执行顺序的显式编排**。