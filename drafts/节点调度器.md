# 节点调度器

我们初步构建出一套**面向 Tree-Stacked（TS）结构、分布式、无中心、硬件感知、O(1) 时间复杂度**的完整调度模型。以下是对 **EDSOS 节点调度器设计** 的系统性总结，涵盖 **调度器架构、数据结构、执行模型、性能保障** 四大核心维度。

---

## 一、调度器核心目标

> **即使调度频率远高于传统 OS，调度开销占比仍更低，且调度行为带来正向性能收益（TLB/缓存亲和、并行扩展）。**
> 目标是单次正常切换带来的全部阻塞性耗时在百纳秒级。

为实现此目标，调度器设计遵循四大原则：

1. **调度前置**：调度决策在节点入队时完成，调度本身退化为 O(1) 安全检查和节点切换；
2. **结构引导**：TS 树的拓扑结构直接决定任务分布策略；
3. **去中心化**：无全局调度器、无全局队列，完全分布式；
4. **硬件协同**：利用 PCID、TLB、RDTSC 等硬件特性隐藏开销。

---

## 二、调度器架构：Per-Core 实例 + 指令嵌入

### 2.1 调度器不是 TS 节点
- **不挂载在任何 TS 树中**，避免破坏偏序语义；
- **不作为独立执行实体存在**，而是：
  - 内核态：管理就绪队列、PCID、负载状态；
  - 用户态：通过 **trampoline 指令** 嵌入节点执行流末尾&头部。

### 2.2 调度触发方式
- **协作式**（主）：节点执行结束 → 调用 trampoline；
- **抢占式**（辅）：timer interrupt → 中断处理程序触发 trampoline。

### 2.3 调度流程（O(1)）
```c
// 1. trampoline 保存当前节点状态
// 2. 通知调度器（syscall）
// 3. 调度器切换 CR3，jmp next_node（已预计算）
// 4. trampoline 预热 TLB（用户态访存触发）
```
- **调度决策 ≠ 调度执行**：决策在入队时完成，执行仅验证。

---

## 三、就绪队列数据结构：Distributed Ready Forest

### 3.1 核心结构：Per-Core MPSC 队列
- **每个 CPU core 一个就绪队列**；
- **MPSC（Multi-Producer Single-Consumer）无锁设计**；
- **支持三种插入位置**：
  - 队尾：普通节点（FIFO）/steal 回来的子树；
  - 队头：紧急节点（如中断回调）；
  - 队列中部指定位置：阻塞唤醒优化/依赖链清晰的节点间原子操作/其他优化。

### 3.2 “基地 Core”绑定机制
- 每个 TS 子树（以节点 N 为根）首次 ready 时，绑定到一个 core：
  ```c
  N.subtree_home_core = select_least_loaded_core();
  ```
- 后续该子树所有后代默认插入该 core 队列；
- **优势**：
  - 数据局部性（预热开销小）；
  - 控制局部性（就绪链表的节点相关性高，利于启发式优化调度行为）。

### 3.3 子树拆分与迁移
- **触发条件**：队列过长、子树过大；
- **迁移单位**：整个子子树（非单个节点）；
- **更新绑定**：`M.subtree_home_core = new_core`；
- **保持结构完整性**，避免 TLB 碎片。

---

## 四、负载均衡：去中心化 Work-Stealing++

### 4.1 无全局结构
- **无全局就绪队列**；
- **无中心调度器**；
- 所有协调通过 **peer-to-peer message** 完成。

### 4.2 负载检测
- **指标**：
  - `ready_queue_length`（原子计数器）；
  - `avg_execution_interval`（RDTSC 估算）。
- **阈值**：
  - HIGH_WATERMARK → 主动迁移；
  - LOW_WATERMARK → 主动 steal。

### 4.3 负载转移
- **Give（迁移）**：过载 core 发送子树给目标 core；
- **Get（窃取）**：空闲 core 请求邻居发送子树。

> **子树级迁移** 是关键：保持 TLB & PCID 亲和，避免性能抖动。

---

## 五、硬件协同与性能保障

### 5.1 PCID = 祖链指纹
- **PCID 不标识进程，而标识祖链**；
- **兄弟节点共享 PCID** → 结构演变带来的 TLB 刷新开销最小化；
- **分配策略**：<TODO> 这里需要结合更仔细的图论分析以确定分配和复用策略；不仅是 PCID，PML4也需要重新定义和设计，符合这里以节点为调度执行粒度的全新设计。

### 5.2 TLB 预热 = 用户态访存
- 调度时，trampoline 执行：
  ```asm
  mov rax, [ancestor_gva + 0]   ; 触发 TLB 加载，不等数据
  mov rax, [next_node_gva + 0]
  ```
- 预热无需内核态，利用硬件预取隐藏开销。

### 5.3 性能统计零开销
- **队列长度**：原子计数器；
- **执行间隔**：RDTSC 差值。

---

## 六、与传统模型的本质区别

| 维度 | 传统 OS | EDSOS |
|------|--------|-------|
| 调度单位 | 线程/进程（扁平） | TS 节点（结构化） |
| 调度决策 | 调度时计算 | 入队时确定 |
| 数据结构 | 全局队列 | per-core 队列 |
| 局部性 | 仅内存亲和 | 数据流 + 控制流 + TLB 三重亲和 |
| 扩展性 | 依赖全局协调 | 完全去中心化 |
| 调度开销 | 高（特权切换 + TLB flush） | 极低（trampoline + 预热） |

---

## 七、总结：EDSOS 调度器的哲学

> **“结构即调度策略，局部性即性能，去中心即扩展。”**

- 调度器不是“管理者”，而是 **结构演化的协调者**；
- 节点不是“任务”，而是 **作用域与执行的统一体**；
- 调度不是“开销”，而是 **硬件局部性的放大器**。

通过将 **TS 结构、PCID/TLB、per-core 队列、子树迁移** 深度融合，EDSOS 实现了：
- **O(1) 调度延迟**；
- **百万级节点可扩展**；
- **分布式无中心协调**；
- **调度频率高也不损害性能**。

这标志着操作系统调度模型从 **“任务为中心”** 向 **“结构为中心”** 的范式跃迁。
