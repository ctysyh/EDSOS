# TSL类型系统架构和指针语义与算术

---

## 一、TSL 类型系统架构：外置、契约式、编译期生效

### 1.1 设计哲学
- **自由优先于安全**：TSL 不内置运行时类型检查，不内置访问控制或竞态防护；
- **类型即元数据**：类型不是语言语法的一部分，而是**编译器提示（compiler hints）**；
- **性能导向**：运行时无类型 tag，无动态分派，完全零开销；
- **可扩展性**：支持任意用户定义类型（如 `u8`, `f16`, `simd4x32`），只要提供元信息。

### 1.2 类型的双重本质
每个类型由两部分构成：

| 组成 | 内容 | 作用 |
|------|------|------|
| **类型名称（Type ID）** | 全局唯一标识符，如 `@T_i32` | 用于字段声明、跨节点一致性校验 |
| **类型含义（Type Semantics）** | 结构体 `{ size: ℕ, ops: OpSet, interop: InteropRules }` | 指导编译器进行合法性检查与代码生成 |

#### 简化示例：
```tsl
@T_i32 = {
  size: 4,
  ops: { add, sub, mul, cmp, load, store },
  interop: { cast_to: [@T_u32], cmp_with: [@T_u32] }
}
```

> 这里每种 ops 都需要明确定义其小步语义，同时 interop 需要精细描述每种操作的实现方式。

### 1.3 类型元信息的声明
- 本节点使用的类型元信息需要在本节点 `meta_data` 的 `cptm` 中声明；
- 不过允许特定的语法糖声明复用所属 TS 根节点的声明/复用特定配置文件来简化书写、压缩源码文件，并顺带保证整个 TS 的类型一致性。

### 1.4 编译期类型环境 Θ
- 映射：`Θ : TypeID → {size, ops, interop}`
- 由前端或标准库提供，编译器据此：
  - 计算字段偏移；
  - 检查 opcode 操作数类型是否支持该操作；
  - 验证函数调用参数匹配。

### 1.5 Opcode 的类型无关性
- 所有 opcode（如 `add`, `load`, `cpy`）**本身无类型**；
- 合法性由上下文决定：
  ```text
  add %z %x %y  is well-typed iff
    Γ(%x) = Γ(%y) = Γ(%z) = τ  and  add ∈ Θ(τ).ops
  ```
- **小步语义外置**：具体求值行为（如 IEEE 754 加法）由 `Θ(τ)` 中的 `eval_op` 规则定义，不属于 TSL 语言本体。

### 1.6 运行时行为
- **无类型信息保留**：生成的 TSVM 字节码或 native code 不包含类型元数据；
- **错误处理**：类型错误在编译期报错；运行时越界/UB 由 EDSOS/TSVM 的边界机制捕获（非语言责任）。

---

## 二、指针语义与算术：结构化虚拟地址空间模型

> **本节内容是对于指针类别的类型定义要求。**

### 2.1 核心理念：有用且可控的自由
- **允许指针算术**，但将其约束在**程序员显式声明的结构范围内**；
- **`ance` 字段可参与指针运算**，实现跨节点字段的虚拟连续视图；
- **自由度服务于表达力**：支持构建跨字段数组、动态代码组装等高级模式。

### 2.2 节点虚拟地址空间 $V_n$
每个节点 $n$ 拥有一个**私有的、逻辑连续的虚拟地址空间**：
$$
V_n = [0, L_n)
$$
其布局严格按以下 **8 段顺序** 固定（ABI 级别稳定）：

```Tsl
node example {
    meta_data {
        rntm {
        }
        cptm {
        }
    }
    data {
        ance {
        }
        publ {
        }
        priv {
        }
    }
    code {
        instruct {
        }
        ance {
        }
        publ {
        }
        priv {
        }
    }
}
```

| 段序 | 名称 | 内容 |
|------|------|------|
| 0 | `meta_data` | 节点元信息（限 `rntm` 运行时字段，`cptm` 不保留） |
| 1 | `data_ance` | data 区中的 `ance` 字段（远程引用） |
| 2 | `data_publ` | data 区中的 `publ` 字段（本地存储） |
| 3 | `data_priv` | data 区中的 `priv` 字段（本地存储） |
| 4 | `code_instruct` | 核心指令字节码 |
| 5 | `code_ance` | code 区中的 `ance` 指令（远程引用/lib 声明） |
| 6 | `code_publ` | code 区中的 `publ` 指令（本地存储） |
| 7 | `code_priv` | code 区中的 `priv` 指令（本地存储） |

> **关键性质**：所有字段（包括 `ance`）在 $V_n$ 中拥有**确定的虚拟偏移**，如同一个 struct。

### 2.3 地址映射函数 $\phi_n$
运行时通过分段线性映射将节点虚拟地址转为系统内存地址：
$$
\phi_n(v) =
\begin{cases}
\text{local\_base} + (v - \text{seg.start}) & \text{if } v \in \text{local segment} \\
\text{target\_base} + \text{target\_offset} & \text{if } v \in \text{ance segment}
\end{cases}
$$
- 由 TSVM 在节点实例化或 `lift` 绑定时构建；
- JIT 可优化为查表+加法，近乎零开销。

### 2.4 指针的源节点视角（Source-Node View）
- 指针值 $p$ 的语义依赖其**创建时所在节点 $n_{\text{src}}$**；
- 编译器绑定 $p$ 到 $V_{n_{\text{src}}}$；
- 运行时解析必须使用 $n_{\text{src}}$ 的 `virtual_map`；
- **跨节点传递指针需显式 marshal** 为 `(v, n_src)` 对。

### 2.5 指针算术规则
- 支持任意加减（如 `p + k`）；
- **不强制段内限制**（自由度优先），但：
  - 编译器可发出 warning（如跨越 data/code 边界）；
  - 越界访问由 TSVM 的 guard pages 或 trap handler 捕获。

### 2.6 革命性应用场景
- **跨字段数组**：将 `ance_a.x: i32, ance_b.y: i32` 视为 `[i32; 2]`；
- **动态代码组装**：通过书写节点代码时声明 `code` 内 `ance` 块中字段顺序，构建虚拟指令序列；
- **零拷贝共享**：多个子节点通过不同 $V_n$ 视图访问同一远程字段。

### 2.7 跨语言交互策略
- **临界区政策**：传递给外部语言（如 C）的指针必须对齐到**单个字段起始地址**；
- 编译器对 `extern "C"` 接口做强制检查；
- 符合现有系统编程惯例（不引入新 UB）。

---

## 三、整体协同：类型 + 指针 = 结构化高性能 IR

| 组件 | 作用 | 协同效果 |
|------|------|--------|
| **外置类型系统** | 定义字段大小、操作合法性 | 为指针算术提供对齐与边界依据 |
| **虚拟地址空间** | 提供结构化内存视图 | 使 `ance` 字段可参与指针运算 |
| **源节点视角** | 保证指针语义明确 | 避免全局扁平地址的语义混乱 |
| **ABI 稳定布局** | 保障二进制兼容 | 使 TSL 可作为可靠 IR 层 |

---
