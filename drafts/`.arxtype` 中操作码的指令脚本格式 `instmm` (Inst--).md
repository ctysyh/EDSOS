# `.arxtype` 中操作码的指令脚本格式 `instmm`（Inst--）

> 处在 “人类可读的底层操作描述” 与 “机器可直接映射的汇编生成” 之间的黄金位置，面向编译器后端的、受限的、寄存器显式声明的指令脚本语言，其本质类似于 “带类型安全和结构化语法的内联汇编”

---

## 一、设计哲学：为什么需要 `instmm`？

### 1.1 解决的问题
- **纯 `inst_scri` 过于抽象**：无法表达寄存器分配、SIMD 向量化等硬件细节。
- **纯 `@asm` 过于原始**：缺乏类型检查、字段引用、操作码复用能力，易出错且难维护。
- **传统 IR（如 LLVM IR）过于通用**：不适合直接嵌入到类型契约中作为实现策略。

### 1.2 核心定位
> **`instmm` 是 `.arxtype` 中用于描述 *如何用标准类型的操作码组合出当前类型操作* 的、寄存器显式的、平台无关但寄存器感知的脚本片段。**

它具备以下特征：
- **类型安全**：所有操作必须来自标准类型集（`f32.add`, `i64.shl` 等）。
- **寄存器显式**：通过 `regi {T r}` 声明临时寄存器，编译器不做寄存器分配。
- **无控制流**：仅顺序执行操作码调用。
- **非 IR**：不参与优化，仅作为汇编生成的“模板”。
- **人类友好**：比裸汇编更易读写，支持字段名（`x.real`）而非偏移量。

---

## 二、语义模型与资源约束

### 2.1 操作数角色
| 角色 | 来源 | 可变性 | 存储用途 |
|------|------|--------|----------|
| `OperTarg` (目标) | `targ {(T)a}` | **可写** | **Scratch space**（可用于中间计算） |
| `OperGoal` (输入) | `goal {(T1)x, (T2)y}` | **只读** | 仅提供值，不贡献 scratch 容量 |

### 2.2 寄存器预算模型（关键！）

总可用位宽容量为：

$$
C = \underbrace{\sum_{f \in \text{OperTarg}} \text{size}(f)}_{\text{目标字段提供的 scratch}} + \underbrace{(N_{\text{gpr}} - N_{\text{imm}}) \times W}_{\text{平台通用寄存器净容量}}
$$

其中：
- $W$：目标平台字长（如 x86_64 为 64 bits）；
- $N_{\text{gpr}}$：ABI 可用通用寄存器数量（如 System V ABI 为 6 个整数寄存器）；
- $N_{\text{imm}}$：`code` 中出现的立即数字面量数量（每个需一个寄存器加载）；
- **`regi` 声明的寄存器总 size 必须 ≤ C**。

> **示例**：在 `complex_f32.add` 中，`a` 是 `OperTarg`（64 bits scratch），若平台有 2 个可用 XMM 寄存器（$N_{\text{gpr}}=2$, $W=128$），无立即数，则 $C = 64 + 2×128 = 320$ bits。声明 `regi {f32 xmm0}`（32 bits）完全合法。

### 2.3 嵌套调用的寄存器叠加

当 `instmm` 调用 `f32.add (xmm0) (x.real, y.real)` 时：
- `f32.add` 自身可能在其 `instmm` 或 `@asm` 中使用 1 个寄存器；
- 此处的 `xmm0` 是外层寄存器；
- **编译器在展开时，会将内外层寄存器需求相加**，并校验是否超限。

> 这意味着 `instmm` 编写者必须了解被调用操作码的寄存器消耗！这是其“靠近终点”的体现——它假设你已知底层实现成本。

---

## 三、`instmm` 语法规范（草案）

```ebnf
InstmmBlock = "@instmm" "{" RegDeclList CodeBlock "}" ;

RegDeclList = { "regi" "{" TypeIdent RegName "}" } ;

CodeBlock = "code" "{" { OpCodeCall ";" } "}" ;

OpCodeCall = 
    "(" TypeIdent ")" OpName 
    "(" RetList ")" 
    "(" ArgList ")" ;

RetList = "(" (RegName | FieldRef) ")" { "(" ... ")" } ;
ArgList = "(" (RegName | FieldRef | Immediate) ")" { "(" ... ")" } ;

FieldRef = Ident "." Ident ;  (* e.g., x.real *)

Immediate = Number | Letter ; (* treated as literals requiring reg slot *)

RegName = Ident ;             (* e.g., xmm0, rax, tmp0 *)

TypeIdent = Ident ;           (* e.g., f32 *)
```

### 关键约束（静态检查）：
1. 所有 `TypeIdent.OpName` 必须存在于**标准类型集**的 `.arxtype` 中；
2. `FieldRef` 中的字段必须属于 `OperTarg` 或 `OperGoal` 声明的变量；
3. `RegName` 必须在 `RegDeclList` 中预先声明；
4. 总寄存器位宽 ≤ 预算 $C$（由编译器根据目标平台和操作数计算）；
5. 不允许递归调用、循环、分支。

---

## 四、在编译链条中的定位：终点前的“最后一公里”

### 4.1 对 AOT 编译器（原生级/兼容级）
- **输入**：`.arxtype` + 源码 AST
- **处理流程**：
  1. 类型解析 → 加载 `.arxtype`
  2. 遇到 `add(a, b)` → 查询 `a` 的类型 → 找到 `ops.add` 的 `@instmm` 实现
  3. **展开 `instmm`**：将 `f32.add(...)` 替换为其对应的 `@asm` 或 `native` 汇编模板
  4. **寄存器分配固化**：将 `regi {f32 xmm0}` 映射为真实寄存器（如 `%xmm0`）
  5. **拼接生成最终汇编**
- **输出**：目标平台机器码

> `instmm` 在此过程中**被完全展开并丢弃**，不出现在任何中间表示中。

### 4.2 对 JIT 编译器（托管级 / ArxilVM）
- **输入**：Arxil Instruct 字节码 + `.arxtype`
- **处理流程**：
  1. JIT 遇到 `ADD` 指令 → 查询操作数类型 → 加载 `.arxtype`
  2. 若存在 `@instmm`，则：
     - 将其视为“高效内联路径”
     - **直接生成等效的 VM 内部指令序列**（如 `LOAD_FIELD`, `F32_ADD`, `STORE_FIELD`）
     - 或进一步编译为本地代码（若支持 tiered compilation）
- **关键**：JIT **不解释 `instmm`**，而是将其编译为更底层的表示。

> `instmm` 对 VM 而言是“编译提示”，而非执行单元。

---

## 五、与 C 内联汇编的类比

| 特性 | C `asm` | Arxil `@instmm` |
|------|--------|----------------|
| 目的 | 插入汇编 | 描述底层操作组合 |
| 类型安全 | 无 | 强类型（字段、操作码） |
| 可移植性 | 平台相关 | 平台无关（但寄存器名可映射） |
| 抽象层级 | 汇编指令 | 标准类型操作码 |
| 寄存器管理 | 手动指定 | 手动声明 + 编译器校验容量 |
| 可读性 | 低 | 中高（支持 `x.real`） |

> `@instmm` = **“带类型系统的、结构化的、可组合的内联汇编”**。

实际上，`arxtype` 里也有 `asm`，正是它定义了标准类型集中对于基本类型操作的目标平台汇编。此外，所有的自定义 `arxtype` 都允许（且推荐）书写 `asm`，声明寄存器和目标平台硬件指令级别的极致优化。

---

## 六、总结：`instmm` 的战略价值

1. **桥接抽象与性能**：让开发者能在 `.arxtype` 中写出接近手写汇编的高效代码，同时享受类型安全和字段引用便利。
2. **赋能标准类型集**：使 `f32`, `i64` 等基础类型的 `.arxtype` 成为真正的“构建块”，可被组合出复杂类型的操作。
3. **统一三级模型**：无论 AOT 还是 JIT，都可通过同一份 `@instmm` 生成接近最优实现。
4. **保持 `.arxtype` 纯净**：不引入控制流、不破坏其“契约”本质，仅增强其表达底层操作的能力。

**最终，`instmm` 不是语言的一部分，而是类型契约的“实现方言”——它是写给编译器后端看的，但用人能理解的方式书写**。