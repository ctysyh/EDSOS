# 1.2 Memory Subsystem

> **This is an old version.**

## 1.2.1 存储设备
- 存储单元分为四个距离层级, 各自包含不同的速度层级: 
  - 本地: 近距内存/缓存
  - 本机: 内存、高速硬盘 (可选)、低速磁盘 (可选)
  - 邻机: 内存、高速硬盘 (可选)、低速磁盘 (可选)
  - 远机: 内存 (可选)、高速硬盘 (可选)、低速磁盘 (可选)
- 每个距离层级至少包含一个速度层级的存储单元
- 对于内存和用作内存映射的高速磁盘, 使用统一的分页管理 (见1.2.2), 其总容量称为*物理分页存储单元容量 Physical Paged Storage Unit Capacity (PPSUC)*

## 1.2.2 地址空间模型
- 全局虚拟地址 (GVA): 128 位结构, 在整个集群内共享
  - 高 32 位: ref 索引和其他编号
  - 次高 32 位: ref 正本分配时的机器 ID
  - 低 64 位: ref 正本分配时的 LVA
  - ref 副本的 GVA 除了 ref 索引外, 其他位与 ref 正本的 GVA 相同
  - GVA 创建之后, 其编号除了进程索引部分, 没有任何实际意义
- 局部虚拟地址 (LVA): 64 位, 就是本机 CPU 和 MMU 使用的虚拟地址
- GVA ↔ LVA 映射: 由本机 DPU 维护, 对 CPU 透明；在集群范围内、任一时刻, 一个 GVA 只对应一个*有效*的 LVA
- 统一页表项: 虽然没有统一的全局页表, 但是跟随 GVA 的储存附带一个结构固定的 128 位页表项
  - 高 16 位: 标识位
  - 次高 48 位: 版本号
  - 低 64 位: 本机内 LVA 对应的 PTE
- 支持标准页 / 大页 / 超大页 / 小页

## 1.2.3 内存分配与归属
- 分配者即初始所有者 (owner_pm)；每个 VP 的 owner_pm 在任意时刻唯一, 可通过所有权协议转移
- 物理容量约束: 任一主机所有的 VP 容量达到 PPSUC 时, 不允许新的 VP 分配
- LVA 的分配继承标准策略, 由 PM 决定其值和指代的 PA

## 1.2.4 双一致性协议架构
- 由 DPU 实现的跨机一致性协议架构类似于多核 CPU 内的微架构, 但考虑跨机特点进行了一些修改

### 路径缓存协议 (Path-Caching Protocol)
- 语义: 支持高效跨机读写与原子操作
- 机制: 
  - 控制流的分支迁移到另一个 PM, 随之带来进程空间的扩张
  - 数据流伴随控制流迁移, 新 PM 触发 `ref` 并拷贝获取整个 VP, 在 `ref` 建立过程中建立路径缓存
  - 路径缓存的 MidPoint 缓存 (保存在沿路的 DPU 中) 包括 VP 的正本 GVA, 归属的副本 bit_map, HostPoint 方向最近一跳, EndPoint 方向最近一跳; HostPoint 缓存额外包括归属副本 bit_map 所对应的 PM; EndPoint 缓存额外包括正本所在的 PM
  - 分布式自动路由: 完全通过路径缓存记录下对应于 VP 的一致性消息的路由方向, 由路径缓存解析器 (PCAU, Path Caching Analysis Unit) 负责解析, 不需中心目录, 只需 GVA 即可自动导向正确的 PM
  - 版本与确认: `RefReq` / `RefAck` 及其他成对指令对应携带相同的由新 PM 生成 (在新 PM 范围内单调增) 的Transaction ID, 旧 PM 在 `RefReq` 时缓存, 在 `RefAck` 时删除; 同时指令携带 TTL, 超时废弃并报告
  - 新 PM (非 owner_pm) 触发写操作时, `SWReq (Submit Write)` 指令伴随 Write-Update 沿缓存路径传播到达 owner_pm, owner_pm 触发 `WUReq` (对于小数据) 或 `WIReq` (对于大数据) 携带触发者的 bit_map, 由 PCAU 自动向其他副本转发 & 向触发者返回 `SWAck`, 仍由 PCAU 自动缓存 Transaction ID 并在其他副本全部返回 `WUAck` / `WIAck` 时向主机返回 `WUAck` / `WIAck`
  - 旧 PM (owner_pm) 触发写操作时, 直接触发 `WUReq` (对于小数据) 或 `WIReq` (对于大数据); 这里实际上意味着 owner_pm 类似于 MESIF 中的 Forward
  - 任何非 owner_pm 触发读操作时需要检查是否有 `Invalid` 标记, 如果是则触发 `ReadReq` 从 owner_pm 处读取得到*已知最新*的版本; 不对数据 (VP) 本身记录版本, 只对一致性协议消息记录版本
  - 当控制流退出一个 PM 时, 进程空间随之收缩, 触发 `UnrefReq` 自动清理路径, 但必须等待 `UnrefAck` 才能安全退出
- 适用场景: 高频读、乐观并发共享、页范围原子操作

### 所有权转移协议 (Ownership-Transfer Protocol)
- 语义: 实现强一致性读写 / 分布式锁 / 迁移
- 机制: 
  - 请求: 在建立了基于路径缓存的 `ref` 之后, 控制流可以主动触发 `OwnReq`; 当旧 owner_pm 发现自己不再是 owner_pm 时, 也可以根据对应的 Config Tag 寄存器在要求 "始终按照所有者身份读写" 时自动触发 `OwnReq`; 触发之后请求者需要锁定本地的副本 VP, 拒绝新的 store
  - 仲裁: `OwnReq` 到达当前 owner_pm 后触发仲裁流程, 仲裁主要基于指令传播到达的先后顺序（包括自竞争指令）; 只有当多个指令在同一个时钟周期同时到达时, 根据可交换标识 & 租期状态 / 优先级 / 公平防饿 / 端口序号仲裁出归属; 不论是否获得所有权, 都会*立即*（固定的时钟周期数量）返回一个响应 (`OwnAck` / `OwnFail`); 仲裁发生在当前 owner_pm, 它拥有最高的权限, 可以将一个指定的寄存器置高来声明处于"不可被换出状态", 但是这个状态会在DPU内硬件计时, 不可超出上限, "超出上限主机未响应"是一个触发报告主机故障的场景
  - 所有权与数据迁移: 当 owner_pm 的仲裁器给出仲裁允许转移和请求方收到 `OwnAck` 时, 各自向 PCAU 提交一个 `Stall`, 一切在此期间到达的 VP 一致性消息都临时写入缓存等待; 同时 owner_pm 并行地在主机本地对 LVA 标记缺页; 请求方在收到 `OwnAck` 时消息附加完整的正本内容, 直接 DMA 写入原副本 VP 对应的 PP中; 接收完成 (接收字节量 & ECC 校验) 后请求方返回 `ROAck (Receive Owning)`, 附带完整的旧副本元数据
  - 元数据确认与路径缓存更新: 原 owner_pm 收到 `ROAck` 后更新本机的 GVA 和 LVA 页表项, 并重置与 owner_pm 相关的寄存器, 完成后发送一个特殊的 `PCEReq (Path Caching Exchange)` 要求 MidPoint 中的路径缓存交换方向并附带 HostPoint 所需的额外数据; 请求方收到 `PCEReq` 说明路径缓存的 MidPoint 更新完成, 触发 `PCEAck` 附带 EndPoint 的额外数据, 交换双方的 HostPoint / EndPoint 标记, 消除 PCAU 的 `Stall`, 恢复运行

## 1.2.5 数据一致性和性能保证
### PTE 标识
- 防止未完成写或本机原子操作期间转移
- 防止转移期间写
- 防止租期内转移

## 1.2.6 原子操作支持 (软件-硬件协同)
<TODO>

## 1.2.7 故障与恢复
- PM 失效检测: DPU 超时/心跳机制
- 自动清理: `dpu_cleanup_pm_refs` 移除失效路径
- 所有权接管: owner_pm 主机失效时各个 ref_pm 自主票选出新的 owner_pm, 由其 DPU (独立供电) 按简化流程转移所有权, 并使用新 owner_pm 所有的副本作为新的正本

## 1.2.8 性能与扩展性
- 读优化: 本地副本 + 路径缓存快速传输
- 写优化: 租期减少转移
- 拓扑自适应: 路径缓存隐式适配互联结构
- 协议插件: 支持未来的一致性模型

> 值得注意的是，无论是路径缓存协议还是所有权协议，都支持一致性读和一致性写，它们的功能区别是一致性的强弱。路径缓存协议也可以用于最终一致写、所有权协议也可以用于强一致读。