# `.tsltype` EBNF Specification

> Agreement:
> - All terminal symbols are indicated by double quotation marks `""`;
> - `(*... *)` is a note;
> - `[X]` indicates optional, and `{X}` indicates zero or multiple repetitions;
> - Uppercase identifiers are non-terminal symbols.

---

```ebnf
TSLTypeFile = TypeDecl ;

TypeDecl = "type", IDENT, "{",
             TypeName,
             TypeSize,
             [TypeLayout],
             [TypeOps],
             [TypeInterop],
             [TypeValidators],
             [TypeDocs],
             [TypeHints],
           "}" ;

TypeName = "name", "=", STRING, ";" ;

TypeSize = "size", "=", INTEGER, ("bits" | "bytes"), ";" ;

TypeLayout = "layout", "{", { LayoutField }, "}" ;

LayoutField = IDENT, "{",
                "offset", "=", BitExpr, ";",
                "width",  "=", BitExpr, ";",
                "type",   "=", IDENT, ";",
                ["tag", "=", STRING, ";"],   (* Optional tag, e.g., "reserved" *)
              "}" ;

BitExpr = INTEGER ;  (* In the future, it can be extended to simple arithmetic expressions, e.g., "8*4" *)

TypeOps = "ops", "{", { OpDecl }, "}" ;

OpDecl = IDENT, "{",
           [OpNative],
           [OpAsmMap],
           [OpLibcall],
           [OpIntrinsic],
           [OpPointerArith],
           [OpUnary],
           [OpMayTrap],
           [OpLoweredTSL],
         "}" ;

OpNative      = "native", "=", BOOLEAN, ";" ;
OpUnary       = "unary", "=", BOOLEAN, ";" ;
OpMayTrap     = "may_trap", "=", BOOLEAN, ";" ;

OpPointerArith = "pointer_arithmetic", "=", BOOLEAN, ";",
                 ["scale_by", "=", INTEGER, ";"] ;

OpAsmMap = "asm", "{", { AsmTarget }, "}" ;

AsmTarget = IDENT, "=", STRING, ";" ;
(* e.g., x86_64 = "addss %xmm0, %xmm1"; *)

OpLibcall = "libcall", "=", STRING, ";" ;
(* e.g., libcall = "__f32_sin"; *)

OpIntrinsic = "intrinsic", "=", BOOLEAN, ";" ;

OpLoweredTSL = "lowered", "=", InstScriBlock, ";" ;

InstScriBlock = "'inst_scri'", "{", { InstLine }, "}" ;

InstLine = IDENT, { Operand }, ";" ;

Operand = IDENT | INTEGER | "(" IDENT ")" ;
(* IDENT here refers to the field name in the layout, or temporary register *)

TypeInterop = "interop", "{",
                [InteropPointerType],
                [InteropImplicitFrom],
                [InteropImplicitTo],
                [InteropBindingCompat],
                [InteropArrayOK],
              "}" ;

InteropPointerType     = "pointer_type", "=", IDENT, ";" ;
InteropImplicitFrom    = "implicit_from", "=", TypeList, ";" ;
InteropImplicitTo      = "implicit_to",   "=", TypeList, ";" ;
InteropBindingCompat   = "binding_compatible_with", "=", TypeList, ";" ;
InteropArrayOK         = "array_element_ok", "=", BOOLEAN, ";" ;

TypeList = "(", [IDENT, { ",", IDENT }], ")" ;

TypeValidators = "validators", "{",
                   [CompileTimeChecks],
                   [RuntimeChecks],
                 "}" ;

CompileTimeChecks = "compile_time", "=", CheckList, ";" ;

RuntimeChecks = "runtime", "{", { RuntimeCheckDecl }, "}" ;

CheckList = "(", [STRING, { ",", STRING }], ")" ;

RuntimeCheckDecl = IDENT, "{",
                     "condition", "=", ConditionExpr, ";",
                     "action", "=", ActionSpec, ";",
                     ["enabled_by_default", "=", BOOLEAN, ";"],
                     ["requires", "=", CapabilityList, ";"],
                   "}" ;

ConditionExpr = STRING ;  (* e.g., "address == 0" *)
ActionSpec = STRING ;     (* e.g., "trap PTR_NULL" *)
CapabilityList = "(", [IDENT, { ",", IDENT }], ")" ;

TypeDocs = "docs", "{",
             [DocUsage],
             [DocErrors],
           "}" ;

DocUsage = "usage", "=", STRING, ";" ;
DocErrors = "errors", "{", { ErrorCodeMapping }, "}" ;

ErrorCodeMapping = IDENT, "=", STRING, ";" ;
(* e.g., PTR_DANGLING = "Dangling pointer dereference" *)

TypeHints = "hints", "{", { HintDecl }, "}" ;

HintDecl = IDENT, "=", (BOOLEAN | INTEGER | STRING), ";" ;
(* e.g., cache_line_aligned = true; simd_eligible = false; *)
```

## Lexical Elements

```ebnf
IDENT       = (LETTER | "_"), { LETTER | DIGIT | "_" | "." } ;
INTEGER     = DIGIT, { DIGIT } ;
STRING      = '"', { CHAR_NO_QUOTE_OR_ESCAPE | ESCAPE_SEQ }, '"' ;
BOOLEAN     = "true" | "false" ;

CHAR_NO_QUOTE_OR_ESCAPE = ? any character except " and \ ? ;
ESCAPE_SEQ  = "\", ("n" | "t" | """ | "\" | "0") ;

LETTER      = "a".."z" | "A".."Z" ;
DIGIT       = "0".."9" ;
```