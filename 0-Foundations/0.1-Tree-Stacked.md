# **Tree-Stacked**

---

## 1. 核心直觉：栈与树的对偶性

- **从执行视角（自底向上）**：控制流是**栈式的**——函数调用压栈，返回弹栈。
- **从结构视角（自顶向下）**：并行任务是**树状的**——父任务派生子任务，形成分叉。

> **TS 的本质**：将这两种视角统一于一个**带偏序的递归结构**中，其中：
> - **栈性** 体现为 **局部线性序（local linear order）**
> - **树性** 体现为 **全局偏序（global partial order）**

---

## 2. 形式化定义

### 定义 1（TS 节点）
一个 **TS 节点** 是一个四元组  
\[
n = (I, P, C, \preceq)
\]  
其中：
- \( I \) 是节点的**唯一标识符**（取自某个无限可数集，如 \( \mathbb{N} \) 或 UUID 空间）
- \( P \subseteq \{n'\} \) 是**父节点集合**，满足 \( |P| \leq 1 \)（即至多一个父节点）
- \( C \subseteq \mathcal{N} \) 是**子节点集合**（\( \mathcal{N} \) 为所有 TS 节点的全集）
- \( \preceq \subseteq C \times C \) 是定义在子节点上的**全序关系**（即栈序）

> 注：\( P \) 为空当且仅当 \( n \) 是根节点。

### 定义 2（TS 结构）
一个 **Tree-Stacked（TS）结构** 是一个节点集合 \( \mathcal{T} \subseteq \mathcal{N} \)，满足：
1. **树性（Tree Property）**：  
   - 存在唯一根节点 \( r \in \mathcal{T} \) 使得 \( P_r = \emptyset \)  
   - 对任意非根节点 \( n \in \mathcal{T} \setminus \{r\} \)，存在唯一路径 \( r \to \cdots \to n \)（无环、连通）
2. **栈性（Stack Property）**：  
   - 对每个节点 \( n \in \mathcal{T} \)，其子节点集合 \( C_n \) 配备一个**全序** \( \preceq_n \)，称为**局部栈序**（local stack order）
3. **一致性（Consistency）**：  
   - 若 \( n' \in C_n \)，则 \( P_{n'} = \{n\} \)

---

## 3. 关键性质分析

### 性质 1：TS 是一棵**有序树**（Ordered Tree）
- 传统有序树仅要求子节点有顺序；
- TS 进一步要求该顺序具有**栈语义**：后加入者在“顶部”，先加入者在“底部”。

### 性质 2：TS 支持两种自然遍历
- **深度优先（DFS）**：按树结构递归访问 → 对应**控制流派生**
- **栈顶优先（Top-First）**：对每个节点，优先访问其 \( \preceq \)-最大子节点 → 对应**最近活跃上下文**

### 性质 3：作用域语义由祖先关系定义
- 定义 **可见性偏序** \( \sqsubseteq \)：  
  \[
  n_1 \sqsubseteq n_2 \iff n_1 \text{ 是 } n_2 \text{ 的祖先（含自身）}
  \]
- 则：**任何在 \( n \) 中创建的资源，对所有 \( m \) 满足 \( n \sqsubseteq m \) 可见**

> 这正是“子节点继承父节点作用域”的数学表达。

---

## 4. 动态操作：TS 的演化规则

TS 不仅是静态结构，更是**可演化的计算状态**。我们定义其基本操作：

### 操作 1：**Push（压栈）**
- 在节点 \( n \) 上创建新子节点 \( n' \)
- 将 \( n' \) 置为 \( C_n \) 中 \( \preceq_n \)-最大的元素（即栈顶）
- 语义：函数调用、任务派生、内存分配

### 操作 2：**Pop（弹栈）**
- 移除 \( C_n \) 中 \( \preceq_n \)-最大的节点 \( n' \)
- 要求：\( C_{n'} = \emptyset \)（即无活跃子任务）
- 语义：函数返回、任务完成、作用域结束

### 操作 3：**Lift（提升作用域）**
- 将节点 \( n' \) 从其父 \( p \) 的子集移除
- 将其添加为 \( a \) 的子节点，其中 \( a \) 是 \( p \) 的祖先（\( a \sqsubseteq p \)）
- 更新 \( \preceq_a \)：将 \( n' \) 插入适当位置（通常置顶）
- 语义：闭包捕获、返回指针、延长生命周期

> **Lift 是 TS 区别于普通栈/树的核心操作**，它打破了“分配点=作用域终点”的限制。

---

## 5. 理论延展：TS 作为计算模型的基元

### 1. **TS 与 λ-演算**
- 每个 λ-抽象可视为一个 TS 节点
- 自由变量的捕获 = Lift 操作
- 应用（application） = Push 新上下文

### 2. **TS 与进程代数（π-calculus）**
- 派生新进程 = Push
- 通道通信 = 跨 TS 的引用（需扩展为 TS 图）
- 作用域限制（νx） = 局部 TS 子树

### 3. **TS 与范畴论**
- TS 节点可视为**对象**
- Lift/Push/Pop 可视为**态射**
- 整个 TS 结构构成一个**自由幺半群作用下的树范畴**

---

## 6. TS 的公理化总结

> **Tree-Stack（TS）是一个带局部全序的有根树，其子节点序列表示栈式作用域，且支持通过祖先提升实现作用域逃逸。**

其全部语义由以下三公理刻画：

1. **树公理**：连通、无环、单根  
2. **栈公理**：每个节点的子集为全序集  
3. **提升公理**：任意节点可重父于其任一祖先

TS 是一种**计算本体论**的表达：

- **栈** 捕获了**时间局部性**（最近使用）
- **树** 捕获了**空间结构性**（并行分叉）
- **提升** 捕获了**语义逃逸**（闭包、共享、持久化）